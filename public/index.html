<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Persona - Professionelle Charaktersimulation</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Add Marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add highlight.js for code syntax highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/highlight.min.js"></script>
  <!-- Add localization support -->
  <script src="/localization.js"></script>
  <style>
    :root {
      --primary-color: #6a5acd;
      --secondary-color: #f8f9fa;
      --accent-color: #9370db;
      --text-color: #333;
      --light-accent: #e6e6fa;
      --dark-accent: #483d8b;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
      --border-radius: 12px;
      --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text-color);
      background-color: #f5f5f7;
      line-height: 1.6;
    }
    
    .navbar {
      background-color: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }
    
    .navbar-brand {
      font-weight: 600;
      color: var(--primary-color);
      font-size: 1.5rem;
    }
    
    .app-subtitle {
      font-size: 0.9rem;
      color: #666;
      font-weight: normal;
    }
    
    .btn-primary {
      background-color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .btn-primary:hover {
      background-color: var(--dark-accent);
      border-color: var(--dark-accent);
    }
    
    .btn-outline-primary {
      color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .btn-outline-primary:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .card {
      border-radius: var(--border-radius);
      border: none;
      box-shadow: var(--card-shadow);
      overflow: hidden;
    }
    
    .card-header {
      background-color: white;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      padding: 1rem 1.5rem;
      font-weight: 600;
    }
    
    .session-info-card {
      background-color: white;
      border-radius: var(--border-radius);
      padding: 12px 20px;
      margin-bottom: 20px;
      box-shadow: var(--card-shadow);
    }
    
    .chat-container {
      height: 550px;
      overflow-y: auto;
      padding: 1.5rem;
      background-color: #ffffff;
    }
    
    .message {
      margin-bottom: 20px;
      max-width: 85%;
      position: relative;
    }
    
    .user-message {
      background-color: var(--light-accent);
      color: var(--text-color);
      padding: 14px 20px;
      border-radius: 18px 18px 4px 18px;
      margin-left: auto;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    .assistant-message {
      background-color: white;
      color: var(--text-color);
      padding: 14px 20px;
      border-radius: 18px 18px 18px 4px;
      margin-right: auto;
      border: 1px solid #eaeaea;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    
    .system-message {
      background-color: rgba(0, 0, 0, 0.03);
      text-align: center;
      font-style: italic;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.85rem;
      color: #666;
      margin: 15px auto;
      max-width: 90%;
    }
    
    .message-avatar {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      margin-right: 12px;
    }
    
    .message-container {
      display: flex;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    
    .message-bubble {
      max-width: calc(100% - 50px);
    }
    
    .message-input-container {
      background-color: white;
      border-top: 1px solid #eaeaea;
      padding: 15px;
      border-radius: 0 0 var(--border-radius) var(--border-radius);
    }
    
    .message-input {
      border-radius: 20px;
      padding: 12px 20px;
      resize: none;
      border: 1px solid #ddd;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: border-color 0.2s, box-shadow 0.2s;
      min-height: 50px;
      max-height: 150px;
    }
    
    .message-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 1px 3px rgba(106, 90, 205, 0.2);
    }
    
    .send-button {
      border-radius: 50%;
      width: 46px;
      height: 46px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .character-selection {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .character-card {
      border-radius: var(--border-radius);
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      height: 100%;
    }
    
    .character-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }
    
    .character-card.selected {
      border: 2px solid var(--primary-color);
    }
    
    .character-img {
      height: 160px;
      background-size: cover;
      background-position: center;
    }
    
    .char-detective {
      background-image: url('/api/placeholder/300/160');
      background-color: #4a6572;
    }
    
    .char-mentor {
      background-image: url('/api/placeholder/300/160');
      background-color: #617c58;
    }
    
    .char-therapist {
      background-image: url('/api/placeholder/300/160');
      background-color: #81a4cd;
    }
    
    .char-coach {
      background-image: url('/api/placeholder/300/160');
      background-color: #b57e50;
    }
    
    .char-creative {
      background-image: url('/api/placeholder/300/160');
      background-color: #a45c94;
    }
    
    .char-custom {
      background-image: url('/api/placeholder/300/160');
      background-color: #8e7cc3;
    }
    
    .character-info {
      padding: 15px;
    }
    
    .memory-container {
      height: 300px;
      overflow-y: auto;
      padding: 0.5rem;
    }
    
    .memory-item {
      padding: 10px 15px;
      border-radius: 8px;
      margin-bottom: 8px;
      background-color: #f8f9fa;
      border-left: 3px solid var(--primary-color);
      font-size: 0.9rem;
      transition: background-color 0.2s, transform 0.2s;
    }
    
    .memory-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .memory-item.compressed {
      background-color: #f0f0ff;
      border-left-color: var(--accent-color);
    }
    
    .memory-item.high-importance {
      border-left-width: 5px;
      border-left-color: #9370db;
      background-color: rgba(147, 112, 219, 0.05);
    }
    
    .memory-item.medium-importance {
      border-left-width: 4px;
    }
    
    .memory-item.low-importance {
      border-left-color: rgba(106, 90, 205, 0.5);
      opacity: 0.9;
    }
    
    .memory-group-header {
      padding: 8px 5px;
      margin-top: 10px;
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 0.85rem;
      border-bottom: 1px solid #eee;
    }
    
    .memory-metadata {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #666;
      border-top: 1px solid #eee;
      padding-top: 6px;
    }
    
    .tooltip-text {
      visibility: hidden;
      width: 300px;
      background-color: #333;
      color: white;
      text-align: left;
      border-radius: 8px;
      padding: 12px;
      position: absolute;
      z-index: 100;
      bottom: 125%;
      left: 50%;
      margin-left: -150px;
      opacity: 0;
      transition: opacity 0.2s, visibility 0.2s, transform 0.2s;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      transform: translateY(10px);
      pointer-events: none; /* Prevents flickering */
    }
    
    /* We now use JS event listeners instead */
    .tooltip-visible {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Add special styling for the memory content */
    .memory-content {
      position: relative;
      z-index: 1;
    }
    
    .compression-stats {
      font-size: 0.85rem;
      color: #666;
    }
    
    .progress {
      height: 6px;
      border-radius: 3px;
      margin: 8px 0;
    }
    
    .form-floating > label {
      padding: 0.75rem 1.25rem;
    }
    
    .form-floating > .form-control {
      padding: 1.25rem 1rem;
    }
    
    .welcome-message {
      text-align: center;
      padding: 2rem;
    }
    
    .welcome-message h2 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }
    
    /* For better mobile experience */
    @media (max-width: 768px) {
      .message {
        max-width: 90%;
      }
      
      .character-selection {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-light py-3">
    <div class="container">
      <a class="navbar-brand d-flex align-items-center" href="#">
        <i class="fas fa-comments me-2" style="color: var(--primary-color);"></i>
        Persona <span class="app-subtitle ms-2" data-i18n="app_subtitle">Professional Character Simulation</span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item">
            <button id="new-session-btn" class="btn btn-outline-primary me-2">
              <i class="fas fa-plus-circle me-1"></i> <span data-i18n="new_session_btn">New Session</span>
            </button>
          </li>
          <li class="nav-item">
            <button id="load-session-btn" class="btn btn-outline-primary">
              <i class="fas fa-folder-open me-1"></i> <span data-i18n="load_session_btn">Load Session</span>
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container my-4">
    <!-- Session Info Card -->
    <div id="session-info-card" class="session-info-card d-flex justify-content-between align-items-center" style="display: none;">
      <div>
        <span id="session-info" class="fw-semibold" data-i18n="no_active_session">No active session</span>
        <span class="text-muted ms-2 small" id="save-status"></span>
      </div>
      <button id="save-session-btn" class="btn btn-sm btn-primary" disabled>
        <i class="fas fa-save me-1"></i> <span data-i18n="save_session_btn">Save Session</span>
      </button>
    </div>
    
    <!-- Setup Container -->
    <div id="setup-container">
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span data-i18n="create_simulation_title">Create Your Simulation</span>
        </div>
        <div class="card-body">
          <!-- API Key Input -->
          <div class="form-floating mb-3">
            <input type="password" class="form-control" id="api-key" placeholder="Enter your API key" data-i18n-placeholder="api_key_placeholder">
            <label for="api-key" data-i18n="api_key_label">Anthropic API Key (Optional)</label>
            <div class="form-text" data-i18n="api_key_help">Leave blank to use the server's default API key if configured.</div>
          </div>
          
          <!-- Character Selection Dropdown -->
          <div class="mb-4">
            <label for="character-select" class="form-label fw-bold" data-i18n="select_character_label">Select Character Type</label>
            <select class="form-select form-select-lg" id="character-select">
              <option value="" selected disabled data-i18n="select_character_placeholder">Choose a character to simulate...</option>
              <option value="mentor" data-i18n="character_career_mentor">Career Mentor - Professional development guidance</option>
              <option value="therapist" data-i18n="character_listener">Supportive Listener - Emotional support and processing</option>
              <option value="coach" data-i18n="character_life_coach">Life Coach - Personal goals and self-improvement</option>
              <option value="mother" data-i18n="character_divorced_mother">Divorced Mother - Life topics</option>
              <option value="wife" data-i18n="character_married_wife">Alexandra Rutz - Married Wife</option>
              <option value="detective" data-i18n="character_inspector">Inspector Blackwood - Analytical problem solver</option>
              <option value="girl" data-i18n="character_teenage_girl">Teenage girl - Adolescent problems</option>
              <option value="matildaMartin" data-i18n="character_matilda">Matilda - A fantasy novel hero</option>
              <option value="adiposeGirl" data-i18n="character_adipose_girl">Adipose girl - Body looks discussions</option>
              <option value="custom" data-i18n="character_custom">Custom Character - Create your own</option>
            </select>
            <div class="form-text" data-i18n="character_select_help">Select a character type for your conversation simulation.</div>
          </div>
          
          <!-- Character Description Panel -->
          <div class="card mb-4" id="character-description-panel" style="display: none;">
            <div class="card-body">
              <div class="row align-items-center">
                <div class="col-md-3 text-center mb-3 mb-md-0">
                  <div id="character-preview" class="rounded-circle mx-auto" style="width: 100px; height: 100px; background-color: var(--primary-color);"></div>
                </div>
                <div class="col-md-9">
                  <h5 id="character-title" class="card-title">Character Name</h5>
                  <p id="character-description" class="card-text">Character description will appear here.</p>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Custom Character Configuration -->
          <div id="custom-character-container" class="mt-4" style="display: none;">
            <div class="card">
              <div class="card-header">Custom Character Profile</div>
              <div class="card-body">
                <div class="form-floating mb-3">
                  <textarea class="form-control" id="custom-profile" rows="5" style="height: 150px"></textarea>
                  <label for="custom-profile">Custom Character Profile (JSON)</label>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Starting Scenario -->
          <div class="mt-4">
            <div class="form-floating mb-3">
              <textarea class="form-control" id="start-scenario" rows="3" style="height: 100px"></textarea>
              <label for="start-scenario">Starting Scenario (Optional)</label>
              <div class="form-text">Describe the initial context for your conversation with the character.</div>
            </div>
          </div>
          
          <!-- Deep Memory Configuration -->
          <div class="card mt-3">
            <div class="card-header">Deep Memory</div>
            <div class="card-body">
              <div class="form-floating mb-3">
                <textarea class="form-control" id="deep-memory" rows="3" style="height: 100px"></textarea>
                <label for="deep-memory">Persistent Deep Memory</label>
                <div class="form-text">Add important information that will never be compressed or forgotten. This will always be included with each prompt.</div>
              </div>
            </div>
          </div>

          <!-- Advanced Options -->
          <div class="card mt-3">
            <div class="card-header">Advanced Options</div>
            <div class="card-body">
              <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" id="enable-compression" checked>
                <label class="form-check-label" for="enable-compression">Enable Memory Compression</label>
                <div class="form-text">Periodically summarizes conversation history to optimize performance.</div>
              </div>
              
              <div class="mb-3">
                <label for="model-select" class="form-label">Model</label>
                <select class="form-select" id="model-select">
                  <option value="claude-3-7-sonnet-20250219" selected>Claude 3.7 Sonnet</option>
                  <option value="claude-3-5-sonnet-20240620">Claude 3.5 Sonnet</option>
                  <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                  <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                  <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                </select>
                <div class="form-text">Select the Claude model to use for this character.</div>
              </div>
              
              <div class="mb-3">
                <label for="language-select" class="form-label" data-i18n="language_label">Language</label>
                <select class="form-select" id="language-select">
                  <option value="english" selected>English</option>
                  <option value="deutsch">Deutsch</option>
                </select>
                <div class="form-text" data-i18n="language_help">Select the language for your conversation with the character.</div>
              </div>
            </div>
          </div>
          
          <!-- Start Button -->
          <div class="mt-4 text-center">
            <button id="start-session" class="btn btn-primary btn-lg">
              <i class="fas fa-play-circle me-2"></i> <span data-i18n="start_session_btn">Start Session</span>
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Session Loading -->
    <div id="session-loader" style="display: none;">
      <div class="card">
        <div class="card-header" data-i18n="load_saved_session_title">Load Saved Session</div>
        <div class="card-body">
          <div class="mb-3">
            <label for="session-select" class="form-label" data-i18n="select_session_label">Select a saved session</label>
            <select class="form-select" id="session-select">
              <option value="" data-i18n="select_session_placeholder">Choose a session to continue...</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="load-api-key" class="form-label" data-i18n="load_api_key_label">API Key (if different from original)</label>
            <input type="password" class="form-control" id="load-api-key" placeholder="Enter API key if needed" data-i18n-placeholder="load_api_key_placeholder">
          </div>
          <div class="mb-3">
            <label for="load-model-select" class="form-label" data-i18n="load_model_label">Model (optional)</label>
            <select class="form-select" id="load-model-select">
              <option value="" data-i18n="use_original_model">Use original model</option>
              <option value="claude-3-7-sonnet-20250219">Claude 3.7 Sonnet</option>
              <option value="claude-3-5-sonnet-20240620">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-20240229">Claude 3 Opus</option>
              <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
              <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
            </select>
            <div class="form-text" data-i18n="load_model_help">Select a different model or leave as is to use the original.</div>
          </div>
          
          <div class="mb-3">
            <label for="load-language-select" class="form-label" data-i18n="language_label">Language</label>
            <select class="form-select" id="load-language-select">
              <option value="english" selected>English</option>
              <option value="deutsch">Deutsch</option>
            </select>
            <div class="form-text" data-i18n="language_help">Select the language for your conversation with the character.</div>
          </div>
          <div class="d-flex justify-content-between">
            <button id="cancel-load" class="btn btn-outline-secondary" data-i18n="cancel_btn">Cancel</button>
            <div>
              <button id="delete-session" class="btn btn-outline-danger me-2" data-i18n="delete_session_btn">Delete Session</button>
              <button id="load-session" class="btn btn-primary" data-i18n="load_session_confirm_btn">Load Session</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Chat Interface -->
    <div id="chat-container" class="row g-4" style="display: none;">
      <div class="col-lg-8">
        <div class="card h-100">
          <div class="card-header d-flex justify-content-between align-items-center">
            <div class="d-flex align-items-center">
              <span id="character-avatar" class="message-avatar d-inline-block me-2 bg-primary"></span>
              <span id="character-name" class="fw-semibold">Character Name</span>
              <div class="dropdown ms-2">
                <span id="model-badge" class="badge bg-secondary small dropdown-toggle" style="font-size: 0.7rem; cursor: pointer;" data-bs-toggle="dropdown" aria-expanded="false"></span>
                <ul class="dropdown-menu model-dropdown" aria-labelledby="model-badge">
                  <li><a class="dropdown-item model-option" data-model="claude-3-7-sonnet-20250219" href="#">Claude 3.7 Sonnet</a></li>
                  <li><a class="dropdown-item model-option" data-model="claude-3-5-sonnet-20240620" href="#">Claude 3.5 Sonnet</a></li>
                  <li><a class="dropdown-item model-option" data-model="claude-3-opus-20240229" href="#">Claude 3 Opus</a></li>
                  <li><a class="dropdown-item model-option" data-model="claude-3-sonnet-20240229" href="#">Claude 3 Sonnet</a></li>
                  <li><a class="dropdown-item model-option" data-model="claude-3-haiku-20240307" href="#">Claude 3 Haiku</a></li>
                </ul>
              </div>
            </div>
            <div>
              <button id="show-memory" class="btn btn-sm btn-outline-primary me-2">
                <i class="fas fa-brain me-1"></i> <span data-i18n="memory_btn">Memory</span>
              </button>
              <button id="compress-memory" class="btn btn-sm btn-primary">
                <i class="fas fa-compress-alt me-1"></i> <span data-i18n="compress_btn">Compress</span>
              </button>
            </div>
          </div>
          
          <!-- Welcome placeholder for empty chat -->
          <div id="welcome-placeholder" class="welcome-message">
            <h2 data-i18n="welcome_title">Welcome to Your Simulation</h2>
            <p data-i18n="welcome_text">Your conversation will appear here. Start by introducing yourself or asking a question.</p>
            <img src="/api/placeholder/300/200" alt="Welcome illustration" class="img-fluid my-4 rounded" style="max-width: 300px;">
          </div>
          
          <!-- Chat messages -->
          <div class="card-body chat-container" id="messages"></div>
          
          <!-- Message input -->
          <div class="message-input-container">
            <div class="input-group">
              <textarea id="message-input" class="form-control message-input" data-i18n-placeholder="message_placeholder" placeholder="Type your message... (Shift+Enter for new line)" rows="1"></textarea>
              <button id="send-message" class="btn btn-primary send-button">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Memory Panel -->
      <div class="col-lg-4" id="memory-panel" style="display: none;">
        <div class="card h-100">
          <div class="card-header" data-i18n="memory_system_title">Memory System</div>
          <div class="card-body d-flex flex-column h-100">
            <ul class="nav nav-tabs mb-3" id="memoryTabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="short-term-tab" data-bs-toggle="tab" data-bs-target="#short-term-content" type="button" role="tab" data-i18n="short_term_label">Short-Term</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="long-term-tab" data-bs-toggle="tab" data-bs-target="#long-term-content" type="button" role="tab" data-i18n="long_term_label">Long-Term</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="deep-memory-tab" data-bs-toggle="tab" data-bs-target="#deep-memory-content" type="button" role="tab" data-i18n="deep_memory_panel_label">Deep Memory</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats-content" type="button" role="tab" data-i18n="stats_label">Stats</button>
              </li>
            </ul>
            
            <div class="tab-content flex-grow-1">
              <!-- Short-Term Memory Tab -->
              <div class="tab-pane fade show active h-100" id="short-term-content" role="tabpanel">
                <div class="memory-container h-100">
                  <ul id="short-term-memory" class="list-unstyled"></ul>
                </div>
              </div>
              
              <!-- Long-Term Memory Tab -->
              <div class="tab-pane fade h-100" id="long-term-content" role="tabpanel">
                <div class="memory-container h-100">
                  <ul id="long-term-memory" class="list-unstyled"></ul>
                </div>
              </div>
              
              <!-- Deep Memory Tab -->
              <div class="tab-pane fade h-100" id="deep-memory-content" role="tabpanel">
                <div class="memory-container h-100">
                  <div id="deep-memory-display" class="mb-3"></div>
                  <div class="form-floating mb-3">
                    <textarea class="form-control" id="update-deep-memory" rows="3" style="height: 100px"></textarea>
                    <label for="update-deep-memory">Update Deep Memory</label>
                  </div>
                  <button id="save-deep-memory" class="btn btn-primary">
                    <i class="fas fa-save me-1"></i> Save Deep Memory
                  </button>
                </div>
              </div>
              
              <!-- Compression Stats Tab -->
              <div class="tab-pane fade" id="stats-content" role="tabpanel">
                <div class="card mb-3">
                  <div class="card-body">
                    <h6 class="card-title">Memory Compression</h6>
                    <div class="form-check form-switch mb-3">
                      <input class="form-check-input" type="checkbox" id="compression-toggle" checked>
                      <label class="form-check-label" for="compression-toggle">Enabled</label>
                    </div>
                    
                    <div class="compression-stats">
                      <p>API calls since last compression: <span id="api-call-count">0</span>/10</p>
                      <div class="progress">
                        <div id="compression-progress-bar" class="progress-bar bg-primary" role="progressbar" style="width: 0%"></div>
                      </div>
                      
                      <p class="mt-3">Last compression: <span id="last-compression-time">Never</span></p>
                      <p>Compression count: <span id="compression-count">0</span></p>
                      <p>Last reduction: <span id="last-compression-ratio">N/A</span></p>
                      
                      <button id="compress-now-btn" class="btn btn-sm btn-primary mt-2">
                        <i class="fas fa-sync-alt me-1"></i> Compress Now
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Localization utility
    let currentLanguage = 'english'; // Default language
    
    function updateUILanguage(language) {
      // Set current language
      currentLanguage = language || 'english';
      document.documentElement.lang = currentLanguage === 'deutsch' ? 'de' : 'en';
      
      // Update document title
      document.title = localization[currentLanguage].page_title;
      
      // Update all elements with data-i18n attribute
      const elements = document.querySelectorAll('[data-i18n]');
      elements.forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (localization[currentLanguage][key]) {
          element.textContent = localization[currentLanguage][key];
        }
      });
      
      // Update placeholders with data-i18n-placeholder attribute
      const placeholders = document.querySelectorAll('[data-i18n-placeholder]');
      placeholders.forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        if (localization[currentLanguage][key]) {
          element.placeholder = localization[currentLanguage][key];
        }
      });
      
      // Update help text with data-i18n-help attribute
      const helpText = document.querySelectorAll('[data-i18n-help]');
      helpText.forEach(element => {
        const key = element.getAttribute('data-i18n-help');
        if (localization[currentLanguage][key]) {
          element.textContent = localization[currentLanguage][key];
        }
      });
    }
    
    // Get text from localization
    function getText(key) {
      return localization[currentLanguage][key] || key;
    }
    
    document.addEventListener('DOMContentLoaded', () => {
      // Function to update model badge
      function updateModelBadge(model) {
        const modelBadge = document.getElementById('model-badge');
        if (!modelBadge) return;
        
        // Extract model name for display
        let displayName = model;
        
        // Format the model name for display
        if (model.includes('claude-3-7')) {
          displayName = 'Claude 3.7 Sonnet';
        } else if (model.includes('claude-3-5')) {
          displayName = 'Claude 3.5 Sonnet';
        } else if (model.includes('claude-3-opus')) {
          displayName = 'Claude 3 Opus';
        } else if (model.includes('claude-3-sonnet') && !model.includes('3-5') && !model.includes('3-7')) {
          displayName = 'Claude 3 Sonnet';
        } else if (model.includes('claude-3-haiku')) {
          displayName = 'Claude 3 Haiku';
        }
        
        modelBadge.textContent = displayName;
        modelBadge.style.display = 'inline-block';
      }
      // Set up model switching
      document.querySelectorAll('.model-option').forEach(option => {
        option.addEventListener('click', event => {
          event.preventDefault();
          if (!activeSessionId) return;
          
          const newModel = event.target.getAttribute('data-model');
          if (!newModel) return;
          
          // Update the model badge
          updateModelBadge(newModel);
          
          // Store the current model for next message
          currentModel = newModel;
          
          // Add system message about model change
          addSystemMessage(`Model switched to ${event.target.textContent}`);
        });
      });
      
      // Variable to store the currently selected model
      let currentModel = 'claude-3-7-sonnet-20250219';
      
      // Configure marked options for security and features
      marked.setOptions({
        gfm: true,
        breaks: true,
        sanitize: false,
        smartLists: true,
        smartypants: true,
        highlight: function(code, lang) {
          if (lang && hljs.getLanguage(lang)) {
            return hljs.highlight(code, { language: lang }).value;
          }
          return hljs.highlightAuto(code).value;
        }
      });
      
      // DOM elements
      const setupContainer = document.getElementById('setup-container');
      const sessionLoader = document.getElementById('session-loader');
      const chatContainer = document.getElementById('chat-container');
      const sessionInfoCard = document.getElementById('session-info-card');
      const welcomePlaceholder = document.getElementById('welcome-placeholder');
      const apiKeyInput = document.getElementById('api-key');
      const characterCards = document.querySelectorAll('.character-card');
      const customCharacterContainer = document.getElementById('custom-character-container');
      const customProfileInput = document.getElementById('custom-profile');
      const startSessionButton = document.getElementById('start-session');
      const characterNameElement = document.getElementById('character-name');
      const characterAvatar = document.getElementById('character-avatar');
      const messagesContainer = document.getElementById('messages');
      const messageInput = document.getElementById('message-input');
      const sendMessageButton = document.getElementById('send-message');
      const showMemoryButton = document.getElementById('show-memory');      
      const compressMemoryButton = document.getElementById('compress-memory');
      const memoryPanel = document.getElementById('memory-panel');
      const shortTermMemoryList = document.getElementById('short-term-memory');
      const longTermMemoryList = document.getElementById('long-term-memory');
      const sessionInfoElement = document.getElementById('session-info');
      const saveStatusElement = document.getElementById('save-status');
      const newSessionButton = document.getElementById('new-session-btn');
      const loadSessionMenuButton = document.getElementById('load-session-btn');
      const saveSessionButton = document.getElementById('save-session-btn');
      const sessionSelectElement = document.getElementById('session-select');
      const loadApiKeyInput = document.getElementById('load-api-key');
      const loadSessionButton = document.getElementById('load-session');
      const deleteSessionButton = document.getElementById('delete-session');
      const cancelLoadButton = document.getElementById('cancel-load');
      const compressionToggle = document.getElementById('compression-toggle');
      const compressNowButton = document.getElementById('compress-now-btn');
      const apiCallCountElement = document.getElementById('api-call-count');
      const lastCompressionTimeElement = document.getElementById('last-compression-time');
      const compressionCountElement = document.getElementById('compression-count');
      const lastCompressionRatioElement = document.getElementById('last-compression-ratio');
      const compressionProgressBar = document.getElementById('compression-progress-bar');
      const enableCompressionCheckbox = document.getElementById('enable-compression');
      
      // Session state
      let activeSessionId = null;
      let selectedCharacterType = null;
      let lastSaveTime = null;
      
      // Handle character dropdown selection
      const characterSelect = document.getElementById('character-select');
      const characterDescriptionPanel = document.getElementById('character-description-panel');
      const characterTitle = document.getElementById('character-title');
      const characterDescription = document.getElementById('character-description');
      const characterPreview = document.getElementById('character-preview');
      
      if (characterSelect) {
        characterSelect.addEventListener('change', () => {
          selectedCharacterType = characterSelect.value;
          
          // Show character description panel
          if (characterDescriptionPanel) {
            characterDescriptionPanel.style.display = 'block';
          }
          
          // Set character information based on selection
          if (characterTitle && characterDescription && characterPreview) {
            switch(selectedCharacterType) {
              case 'mentor':
                characterTitle.textContent = 'Career Mentor';
                characterDescription.textContent = 'An experienced professional who provides guidance on career development, leadership skills, and workplace challenges.';
                characterPreview.style.backgroundColor = '#617c58';
                break;
              case 'therapist':
                characterTitle.textContent = 'Supportive Listener';
                characterDescription.textContent = 'A compassionate listener trained to help you process thoughts, emotions, and navigate life experiences with empathy.';
                characterPreview.style.backgroundColor = '#81a4cd';
                break;
              case 'coach':
                characterTitle.textContent = 'Life Coach';
                characterDescription.textContent = 'A motivational guide focused on helping you achieve personal goals, develop positive habits, and pursue self-improvement.';
                characterPreview.style.backgroundColor = '#b57e50';
                break;
              case 'mother':
                characterTitle.textContent = 'Divorced mother';
                characterDescription.textContent = 'An imaginative partner for brainstorming ideas, creative writing, artistic exploration, and creative problem-solving.';
                characterPreview.style.backgroundColor = '#a45c94';
                break;
              case 'matildaMartin':
                characterTitle.textContent = 'Matilda Martin';
                characterDescription.textContent = 'Character from german fantasy novel.';
                characterPreview.style.backgroundColor = '#4a6572';
                break;
              case 'adiposeGirl':
                characterTitle.textContent = 'Alina Becker';
                characterDescription.textContent = 'Chubby girl with no friends';
                characterPreview.style.backgroundColor = '#4a6572';
                break;
              case 'custom':
                characterTitle.textContent = 'Custom Character';
                characterDescription.textContent = 'Create your own unique character with custom personality traits, background, and expertise.';
                characterPreview.style.backgroundColor = '#8e7cc3';
                break;
            }
          }
          
          // Show custom character container if custom is selected
          if (selectedCharacterType === 'custom') {
            customCharacterContainer.style.display = 'block';
          } else {
            customCharacterContainer.style.display = 'none';
          }
        });
      }
      
      // Auto-resize textarea as user types
      messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
      });
      
      // New session button
      newSessionButton.addEventListener('click', () => {
        setupContainer.style.display = 'block';
        sessionLoader.style.display = 'none';
        chatContainer.style.display = 'none';
        sessionInfoCard.style.display = 'none';
      });
      
      // Load session menu button
      loadSessionMenuButton.addEventListener('click', async () => {
        setupContainer.style.display = 'none';
        chatContainer.style.display = 'none';
        sessionLoader.style.display = 'block';
        
        // Fetch available sessions
        try {
          const response = await fetch('/api/sessions');
          const sessions = await response.json();
          
          // Clear previous options
          sessionSelectElement.innerHTML = '<option value="">Select a saved session...</option>';
          
          // Add sessions to dropdown
          sessions.forEach(session => {
            const option = document.createElement('option');
            option.value = session.sessionId;
            option.textContent = `${session.characterName} - ${new Date(session.timestamp).toLocaleString()}`;
            sessionSelectElement.appendChild(option);
          });
        } catch (error) {
          alert(`Error loading sessions: ${error.message}`);
        }
      });
      
      // Cancel load button
      cancelLoadButton.addEventListener('click', () => {
        sessionLoader.style.display = 'none';
        
        // Show appropriate container based on current state
        if (activeSessionId) {
          chatContainer.style.display = 'block';
          sessionInfoCard.style.display = 'flex';
        } else {
          setupContainer.style.display = 'block';
        }
      });
      
      // Load selected session
      loadSessionButton.addEventListener('click', async () => {
        const sessionId = sessionSelectElement.value;
        if (!sessionId) {
          alert('Please select a session to load');
          return;
        }
        
        try {
          // Load the session
          // Get the selected model if any
          const loadModelSelect = document.getElementById('load-model-select');
          const selectedLoadModel = loadModelSelect ? loadModelSelect.value : '';
          
          // Get selected language
          const loadLanguageSelect = document.getElementById('load-language-select');
          const selectedLanguage = loadLanguageSelect ? loadLanguageSelect.value : 'english';
          
          const response = await fetch('/api/session', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sessionId: sessionId,
              apiKey: loadApiKeyInput.value.trim() || null,
              model: selectedLoadModel || undefined,
              language: selectedLanguage
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Update UI
            activeSessionId = data.sessionId;
            characterNameElement.textContent = data.characterName;
            sessionInfoElement.textContent = `Active session: ${data.characterName}`;
            saveStatusElement.textContent = 'Auto-saving enabled';
            saveSessionButton.disabled = false;
            
            // Set character avatar background color
            setCharacterAvatar(data.characterType);
            
            // Hide setup and show chat
            setupContainer.style.display = 'none';
            sessionLoader.style.display = 'none';
            chatContainer.style.display = 'flex';
            sessionInfoCard.style.display = 'flex';
            
            // Hide welcome placeholder if messages exist
            welcomePlaceholder.style.display = 'none';
            
            // Clear messages and add welcome back message
            messagesContainer.innerHTML = '';
            addSystemMessage(`Session loaded! Continue your conversation with ${data.characterName}.`);
            
            // Update model badge if available
            const modelBadge = document.getElementById('model-badge');
            if (modelBadge && data.model) {
              updateModelBadge(data.model);
            }
            
            // Update memory display if visible
            if (memoryPanel.style.display !== 'none') {
              updateMemoryDisplay(data.memoryState);
            }
                        
            // Update compression toggle
            if (compressionToggle && data.memoryState && data.memoryState.compressionEnabled !== undefined) {
              compressionToggle.checked = data.memoryState.compressionEnabled;
            }
            
            // Update compression stats
            updateCompressionStats();
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error loading session: ${error.message}`);
        }
      });
      
      // Delete selected session
      deleteSessionButton.addEventListener('click', async () => {
        const sessionId = sessionSelectElement.value;
        if (!sessionId) {
          alert('Please select a session to delete');
          return;
        }
        
        if (!confirm('Are you sure you want to delete this session? This cannot be undone.')) {
          return;
        }
        
        try {
          const response = await fetch(`/api/session/${sessionId}`, {
            method: 'DELETE'
          });
          
          const data = await response.json();
          
          if (response.ok) {
            alert('Session deleted successfully');
            
            // Remove from dropdown
            const option = sessionSelectElement.querySelector(`option[value="${sessionId}"]`);
            if (option) {
              option.remove();
            }
            
            // If it was the active session, reset state
            if (activeSessionId === sessionId) {
              activeSessionId = null;
              sessionInfoElement.textContent = 'No active session';
              saveStatusElement.textContent = '';
              saveSessionButton.disabled = true;
              
              // Show setup
              sessionLoader.style.display = 'none';
              chatContainer.style.display = 'none';
              sessionInfoCard.style.display = 'none';
              setupContainer.style.display = 'block';
            }
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error deleting session: ${error.message}`);
        }
      });
      
      // Start new session
      startSessionButton.addEventListener('click', async () => {
        const characterSelect = document.getElementById('character-select');
        selectedCharacterType = characterSelect ? characterSelect.value : selectedCharacterType;
        
        if (!selectedCharacterType) {
          alert('Please select a character type');
          return;
        }
        
        const apiKey = apiKeyInput.value.trim();
        const startScenario = document.getElementById('start-scenario').value.trim();
        const compressionEnabled = enableCompressionCheckbox.checked;
        
        // Get selected model
        const modelSelect = document.getElementById('model-select');
        const selectedModel = modelSelect ? modelSelect.value : 'claude-3-7-sonnet-20250219';
        
        // Get deep memory if provided
        const deepMemory = document.getElementById('deep-memory').value.trim();
        
        // Get selected language
        const languageSelect = document.getElementById('language-select');
        const selectedLanguage = languageSelect ? languageSelect.value : 'english';
        
        // Prepare request data
        const requestData = {
          characterType: selectedCharacterType,
          apiKey: apiKey || null,
          startScenario: startScenario,
          compressionEnabled: compressionEnabled,
          deepMemory: deepMemory,
          model: selectedModel,
          language: selectedLanguage
        };
        
        // Add custom profile if selected
        if (selectedCharacterType === 'custom') {
          try {
            requestData.customProfile = JSON.parse(customProfileInput.value);
          } catch (error) {
            alert('Invalid JSON for custom character profile');
            return;
          }
        }
        
        try {
          // Create session
          const response = await fetch('/api/session', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Save session ID
            activeSessionId = data.sessionId;
            
            // Update UI
            characterNameElement.textContent = data.characterName;
            sessionInfoElement.textContent = `Active session: ${data.characterName}`;
            saveStatusElement.textContent = 'Auto-saving enabled';
            saveSessionButton.disabled = false;
            
            // Set character avatar background color
            setCharacterAvatar(selectedCharacterType);
            
            // Update model badge
            const modelBadge = document.getElementById('model-badge');
            if (modelBadge) {
              updateModelBadge(selectedModel);
            }
                        
            // Set compression toggle state
            if (compressionToggle) {
              compressionToggle.checked = compressionEnabled;
            }
            
            setupContainer.style.display = 'none';
            chatContainer.style.display = 'flex';
            sessionInfoCard.style.display = 'flex';
            
            // Hide welcome after first message
            welcomePlaceholder.style.display = 'block';
            
            // Add welcome message
            addSystemMessage(`Connected! You are now chatting with ${data.characterName}. Try asking about their appearance, background, or how they can help you.`);
                        
            // Initialize compression stats
            updateCompressionStats();
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error starting session: ${error.message}`);
        }
      });
      
      // Send message
      sendMessageButton.addEventListener('click', sendMessage);
      
      // Handle Enter and Shift+Enter in the message input
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          // If Shift key is pressed with Enter, allow default behavior (new line)
          if (!e.shiftKey) {
            e.preventDefault(); // Prevent default Enter behavior (which is new line)
            sendMessage(); // Send the message
          }
        }
      });
      
      async function sendMessage() {
        const message = messageInput.value.trim();
        if (!message || !activeSessionId) return;
        
        // Hide welcome placeholder when first message is sent
        welcomePlaceholder.style.display = 'none';
        
        // Add user message to UI
        addUserMessage(message);
        messageInput.value = '';
        messageInput.style.height = 'auto';
        
        try {
          // Update save status
          saveStatusElement.textContent = 'Sending message...';
          
          // Send message to server
          const response = await fetch('/api/message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sessionId: activeSessionId,
              message,
              model: currentModel // Send the currently selected model
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Add assistant response to UI
            addAssistantMessage(data.response);
            
            // Update memory display if visible
            if (memoryPanel.style.display !== 'none') {
              updateMemoryDisplay(data.memoryState);
            }
            
            // Update model badge if model info is available
            if (data.model) {
              const modelBadge = document.getElementById('model-badge');
              if (modelBadge) {
                updateModelBadge(data.model);
              }
            }
                        
            // Update compression stats
            updateCompressionStats();
            
            // Update save status
            lastSaveTime = new Date();
            saveStatusElement.textContent = `Last saved: ${lastSaveTime.toLocaleTimeString()}`;
          } else {
            addSystemMessage(`Error: ${data.error}`);
            saveStatusElement.textContent = 'Error saving';
          }
        } catch (error) {
          addSystemMessage(`Error sending message: ${error.message}`);
          saveStatusElement.textContent = 'Error saving';
        }
      }
      
      // Show/hide memory panel
      showMemoryButton.addEventListener('click', async () => {
        if (memoryPanel.style.display === 'none') {
          memoryPanel.style.display = 'block';
          showMemoryButton.innerHTML = '<i class="fas fa-brain me-1"></i> Hide Memory';
          
          // Fetch current memory state
          try {
            const response = await fetch(`/api/memory/${activeSessionId}`);
            const memoryState = await response.json();
            updateMemoryDisplay(memoryState);
          } catch (error) {
            console.error('Error fetching memory:', error);
          }
        } else {
          memoryPanel.style.display = 'none';
          showMemoryButton.innerHTML = '<i class="fas fa-brain me-1"></i> Memory';
        }
      });
            
      // Manually compress memory
      if (compressMemoryButton) {
        compressMemoryButton.addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          try {
            compressMemoryButton.disabled = true;
            compressMemoryButton.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Compressing...';
            
            const response = await fetch('/api/compression/compress', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              addSystemMessage(`Memory compression complete: ${data.beforeCount}  ${data.afterCount} items (${data.reductionPercent}% reduction)`);
              
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Update compression stats
              updateCompressionStats();
            } else {
              addSystemMessage(`Compression skipped: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            addSystemMessage(`Error compressing memory: ${error.message}`);
          } finally {
            compressMemoryButton.disabled = false;
            compressMemoryButton.innerHTML = '<i class="fas fa-compress-alt me-1"></i> Compress';
            compressNowButton.disabled = false;
            compressNowButton.innerHTML = '<i class="fas fa-sync-alt me-1"></i> Compress Now';
          }
        });
      }
      
      // Compression toggle change
      if (compressionToggle) {
        compressionToggle.addEventListener('change', async () => {
          if (!activeSessionId) return;
          
          try {
            const response = await fetch('/api/compression/toggle', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId,
                enabled: compressionToggle.checked
              })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
              console.error('Error toggling compression:', data.error);
              // Revert the toggle if there was an error
              compressionToggle.checked = !compressionToggle.checked;
            }
          } catch (error) {
            console.error('Error toggling compression:', error);
            // Revert the toggle if there was an error
            compressionToggle.checked = !compressionToggle.checked;
          }
        });
      }
      
      // Compress now button
      if (compressNowButton) {
        compressNowButton.addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          try {
            compressNowButton.disabled = true;
            compressNowButton.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Compressing...';
            
            const response = await fetch('/api/compression/compress', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId,
                force: true
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              addSystemMessage(`Memory compressed: ${data.beforeCount}  ${data.afterCount} items (${data.reductionPercent}% reduction)`);
              
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Update compression stats
              updateCompressionStats();
            } else {
              addSystemMessage(`Compression skipped: ${data.error || 'Not enough memories to compress'}`);
            }
          } catch (error) {
            console.error('Error compressing memory:', error);
          } finally {
            compressNowButton.disabled = false;
            compressNowButton.innerHTML = '<i class="fas fa-sync-alt me-1"></i> Compress Now';
          }
        });
      }
      
      // Set character avatar based on character type
      function setCharacterAvatar(characterType) {
        if (!characterAvatar) return;
        
        // Remove all existing classes
        characterAvatar.className = 'message-avatar d-inline-block me-2';
        
        // Set background color based on character type
        switch (characterType) {
          case 'mentor':
            characterAvatar.style.backgroundColor = '#617c58';
            break;
          case 'therapist':
            characterAvatar.style.backgroundColor = '#81a4cd';
            break;
          case 'coach':
            characterAvatar.style.backgroundColor = '#b57e50';
            break;
          case 'creative':
            characterAvatar.style.backgroundColor = '#a45c94';
            break;
          case 'detective':
            characterAvatar.style.backgroundColor = '#4a6572';
            break;
          case 'custom':
            characterAvatar.style.backgroundColor = '#8e7cc3';
            break;
          default:
            characterAvatar.style.backgroundColor = 'var(--primary-color)';
        }
      }
      
      // Function to update compression stats
      function updateCompressionStats() {
        if (!activeSessionId) return;
        
        try {
          // If API is available, fetch stats from server
          if (typeof fetch !== 'undefined' && apiCallCountElement) {
            fetch(`/api/compression/stats/${activeSessionId}`)
              .then(response => response.json())
              .then(stats => {
                if (stats) {
                  // Update toggle state
                  if (compressionToggle) {
                    compressionToggle.checked = stats.enabled;
                  }
                  
                  // Update stats display
                  if (apiCallCountElement) {
                    apiCallCountElement.textContent = stats.apiCallsSinceLastCompression;
                    
                    // Update progress bar
                    if (compressionProgressBar) {
                      const percent = Math.min(100, (stats.apiCallsSinceLastCompression / 10) * 100);
                      compressionProgressBar.style.width = `${percent}%`;
                    }
                  }
                  
                  if (compressionCountElement) {
                    compressionCountElement.textContent = stats.compressionCount || '0';
                  }
                  
                  // Format timestamp if available
                  if (lastCompressionTimeElement) {
                    if (stats.lastCompressionTime) {
                      const date = new Date(stats.lastCompressionTime);
                      lastCompressionTimeElement.textContent = date.toLocaleString();
                    } else {
                      lastCompressionTimeElement.textContent = 'Never';
                    }
                  }
                  
                  // Calculate compression ratio if available
                  if (lastCompressionRatioElement) {
                    if (stats.memoriesBeforeLastCompression && stats.memoriesAfterLastCompression) {
                      const ratio = ((stats.memoriesBeforeLastCompression - stats.memoriesAfterLastCompression) / stats.memoriesBeforeLastCompression * 100).toFixed(1);
                      lastCompressionRatioElement.textContent = `${stats.memoriesBeforeLastCompression}  ${stats.memoriesAfterLastCompression} (${ratio}%)`;
                    } else {
                      lastCompressionRatioElement.textContent = 'N/A';
                    }
                  }
                }
              })
              .catch(error => console.error('Error fetching compression stats:', error));
          }
        } catch (error) {
          console.error('Error updating compression stats:', error);
        }
      }
      
      // Helper functions for adding messages
      function addUserMessage(message) {
        // Hide welcome placeholder when first message is sent
        if (welcomePlaceholder) {
          welcomePlaceholder.style.display = 'none';
        }
        
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message user-message';
        messageElement.textContent = message;
        
        // Add to container and append to messages
        messageContainer.appendChild(messageElement);
        messagesContainer.appendChild(messageContainer);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function addAssistantMessage(message) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';
        
        // Create avatar
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        avatar.style.backgroundColor = characterAvatar.style.backgroundColor;
        messageContainer.appendChild(avatar);
        
        // Create message bubble
        const messageBubble = document.createElement('div');
        messageBubble.className = 'message-bubble';
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message assistant-message';
        
        // Parse markdown content
        try {
          // Render the markdown content
          messageElement.innerHTML = marked.parse(message);
          
          // Find all code blocks and apply syntax highlighting
          messageElement.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
          });
        } catch (error) {
          // Fallback to plain text if markdown parsing fails
          console.error('Error parsing markdown:', error);
          messageElement.textContent = message;
        }
        
        messageBubble.appendChild(messageElement);
        messageContainer.appendChild(messageBubble);
        messagesContainer.appendChild(messageContainer);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function addSystemMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = 'system-message';
        messageElement.textContent = message;
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      // Handle deep memory save
      if (document.getElementById('save-deep-memory')) {
        document.getElementById('save-deep-memory').addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          const deepMemoryContent = document.getElementById('update-deep-memory').value.trim();
          
          try {
            const response = await fetch(`/api/deep-memory/${activeSessionId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                content: deepMemoryContent
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              // Update memory display if visible
              if (memoryPanel.style.display !== 'none') {
                updateMemoryDisplay(data.memoryState);
              }
              
              addSystemMessage('Deep memory updated successfully');
            } else {
              addSystemMessage(`Error updating deep memory: ${data.error}`);
            }
          } catch (error) {
            console.error('Error updating deep memory:', error);
            addSystemMessage(`Error updating deep memory: ${error.message}`);
          }
        });
      }
      
      function updateMemoryDisplay(memoryState) {
        if (!memoryState) return;
        
        // Clear current memory display
        shortTermMemoryList.innerHTML = '';
        longTermMemoryList.innerHTML = '';
        
        // Update deep memory display
        const deepMemoryDisplay = document.getElementById('deep-memory-display');
        const updateDeepMemoryInput = document.getElementById('update-deep-memory');
        
        if (deepMemoryDisplay && memoryState.deepMemory) {
          deepMemoryDisplay.innerHTML = `<div class="card p-3 bg-light"><h5>Current Deep Memory:</h5><p>${memoryState.deepMemory.replace(/\n/g, '<br>')}</p></div>`;
        }
        
        if (updateDeepMemoryInput && memoryState.deepMemory) {
          updateDeepMemoryInput.value = memoryState.deepMemory;
        }
        
        // Add short-term memory items
        if (memoryState.shortTerm && Array.isArray(memoryState.shortTerm)) {
          memoryState.shortTerm.forEach(item => {
            const li = createMemoryItem(item, 'short-term');
            shortTermMemoryList.appendChild(li);
          });
        }
        
        // Add long-term memory items - group by topic structure
        if (memoryState.longTerm && Array.isArray(memoryState.longTerm)) {
          // Check if we have topic groups in the memories
          const hasTopicGroups = memoryState.longTerm.some(memory => 
            memory.topicGroup || memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/)
          );
          
          if (hasTopicGroups) {
            // Organize memories by topic groups
            const groupedMemories = {};
            
            // Process and group memories
            memoryState.longTerm.forEach(memory => {
              let group = 'Uncategorized';
              
              // Extract topic group from property or content
              if (memory.topicGroup) {
                group = memory.topicGroup;
              } else {
                // Try to extract from content with format [GROUP:subgroup]
                const topicMatch = memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/);
                if (topicMatch) {
                  group = topicMatch[1];
                } else {
                  // Check for old category format
                  const categoryMatch = memory.content.match(/^\[([A-Z_]+)\]/);
                  if (categoryMatch) {
                    group = categoryMatch[1];
                  }
                }
              }
              
              // Initialize group if it doesn't exist
              if (!groupedMemories[group]) {
                groupedMemories[group] = [];
              }
              
              // Add to group
              groupedMemories[group].push(memory);
            });
            
            // Create topic group headers and add memories under each
            Object.entries(groupedMemories).forEach(([group, memories]) => {
              // Sort memories by importance within each group
              memories.sort((a, b) => (b.importance || 0.5) - (a.importance || 0.5));
              
              // Create group header
              const groupHeader = document.createElement('div');
              groupHeader.className = 'memory-group-header';
              let headerColor = 'secondary';
              
              // Different colors for different topic groups
              if (group === 'USER_IDENTITY') headerColor = 'info';
              else if (group === 'CHARACTER_IDENTITY') headerColor = 'success';
              else if (group === 'RELATIONSHIP') headerColor = 'danger';
              else if (group === 'CONVERSATION_THREADS') headerColor = 'warning';
              
              // Format group name for display
              const displayName = group.replace(/_/g, ' ');
              
              groupHeader.innerHTML = `
                <span class="badge bg-${headerColor} me-2">${displayName}</span>
                <span class="badge bg-light text-dark">${memories.length} items</span>
              `;
              longTermMemoryList.appendChild(groupHeader);
              
              // Add memories in each group
              memories.forEach(memory => {
                const li = createMemoryItem(memory, 'long-term');
                longTermMemoryList.appendChild(li);
              });
              
              // Add separator between groups
              const separator = document.createElement('hr');
              separator.className = 'my-2';
              longTermMemoryList.appendChild(separator);
            });
          } else {
            // Traditional display without grouping
            memoryState.longTerm.forEach(item => {
              const li = createMemoryItem(item, 'long-term');
              longTermMemoryList.appendChild(li);
            });
          }
        }
      }
      
      function createMemoryItem(memory, itemType) {
        const li = document.createElement('li');
        li.className = 'memory-item position-relative';
        
        // Add compressed indicator
        if (memory.compressed) {
          li.classList.add('compressed');
        }
        
        // Add importance-based styling if available
        if (memory.importance !== undefined) {
          // Add importance class based on score
          const importanceScore = memory.importance;
          if (importanceScore >= 0.8) {
            li.classList.add('high-importance');
          } else if (importanceScore >= 0.5) {
            li.classList.add('medium-importance');
          } else {
            li.classList.add('low-importance');
          }
          
          // Set a subtle border color based on importance
          const colorIntensity = Math.floor(memory.importance * 100);
          li.style.borderLeftColor = `rgba(106, 90, 205, ${memory.importance})`;
        }
        
        let contentHTML = '';
        
        if (itemType === 'short-term') {
          // For short-term memory
          contentHTML = `<strong>${memory.role || 'user'}:</strong> ${memory.content.substring(0, 50)}${memory.content.length > 50 ? '...' : ''}`;
        } else {
          // For long-term memory
          let displayContent = memory.content.substring(0, 100) + (memory.content.length > 100 ? '...' : '');
          
          // Extract topic group if available (new format)
          const topicMatch = memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/);
          
          // Add badges for topic group and importance
          let badges = '';
          
          // Add compression badge
          if (memory.compressed) {
            badges += `<span class="badge bg-primary me-1">Compressed</span>`;
          }
          
          // Add topic badge if available
          if (topicMatch) {
            const topicGroup = topicMatch[1];
            let badgeColor = 'bg-secondary';
            
            // Different colors for different topic groups
            if (topicGroup === 'USER_IDENTITY') badgeColor = 'bg-info';
            else if (topicGroup === 'CHARACTER_IDENTITY') badgeColor = 'bg-success';
            else if (topicGroup === 'RELATIONSHIP') badgeColor = 'bg-danger';
            else if (topicGroup === 'CONVERSATION_THREADS') badgeColor = 'bg-warning text-dark';
            
            badges += `<span class="badge ${badgeColor} me-1">${topicGroup.replace('_', ' ')}</span>`;
          } else {
            // Look for old category format [CATEGORY]
            const categoryMatch = memory.content.match(/^\[([A-Z_]+)\]/);
            if (categoryMatch) {
              badges += `<span class="badge bg-secondary me-1">${categoryMatch[1]}</span>`;
            }
          }
          
          // Add importance badge if available
          if (memory.importance !== undefined) {
            const importancePercent = Math.round(memory.importance * 100);
            badges += `<span class="badge bg-info me-1" title="Importance score">${importancePercent}%</span>`;
          }
          
          // Add access count badge if memory has been accessed
          if (memory.accessCount && memory.accessCount > 0) {
            badges += `<span class="badge bg-success me-1" title="Number of times this memory was accessed">Used: ${memory.accessCount}</span>`;
          }
          
          contentHTML = badges ? `<div class="mb-1">${badges}</div>` : '';
          contentHTML += displayContent;
        }
        
        // Create the tooltip with full content
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-text';
        
        if (itemType === 'short-term') {
          tooltip.innerHTML = `<strong>${memory.role || 'user'}:</strong><br>${memory.content}`;
        } else {
          // Enhanced tooltip for long-term memory
          tooltip.innerHTML = `<div class="mb-2">${memory.content}</div>`;
          
          // Add metadata in the tooltip
          let metadataHTML = '<div class="memory-metadata">';
          
          // Add timestamp
          if (memory.timestamp) {
            const date = new Date(memory.timestamp);
            metadataHTML += `<div>Stored: ${date.toLocaleString()}</div>`;
          }
          
          // Add access information
          if (memory.accessCount !== undefined) {
            metadataHTML += `<div>Access count: ${memory.accessCount}</div>`;
            
            if (memory.lastAccessed) {
              const accessDate = new Date(memory.lastAccessed);
              metadataHTML += `<div>Last accessed: ${accessDate.toLocaleString()}</div>`;
            }
          }
          
          // Add importance score
          if (memory.importance !== undefined) {
            const importancePercent = Math.round(memory.importance * 100);
            metadataHTML += `<div>Importance: ${importancePercent}%</div>`;
          }
          
          // Add topic group and subtopic
          if (memory.topicGroup) {
            metadataHTML += `<div>Topic group: ${memory.topicGroup}</div>`;
            
            if (memory.subtopic) {
              metadataHTML += `<div>Subtopic: ${memory.subtopic}</div>`;
            }
          }
          
          // Close metadata div and add to tooltip
          metadataHTML += '</div>';
          tooltip.innerHTML += metadataHTML;
        }
        
        // Create a content wrapper div instead of setting innerHTML directly
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'memory-content';
        contentWrapper.innerHTML = contentHTML;
        
        // Append both content and tooltip to the li element
        li.appendChild(contentWrapper);
        li.appendChild(tooltip);
        
        // Add a manual hover event for better tooltip control
        li.addEventListener('mouseenter', () => {
          tooltip.style.visibility = 'visible';
          tooltip.style.opacity = '1';
        });
        
        li.addEventListener('mouseleave', () => {
          tooltip.style.visibility = 'hidden';
          tooltip.style.opacity = '0';
        });
        
        return li;
      }
      
      // Set up periodic updates for compression stats
      if (activeSessionId) {
        setInterval(updateCompressionStats, 10000); // Every 10 seconds
      }
      
      // Set up language selector event listeners
      const languageSelect = document.getElementById('language-select');
      if (languageSelect) {
        // Initialize with current language
        currentLanguage = languageSelect.value || 'english';
        
        // Add event listener for language changes
        languageSelect.addEventListener('change', (e) => {
          currentLanguage = e.target.value;
          updateUILanguage(currentLanguage);
        });
      }
      
      // Apply translations on page load
      updateUILanguage(currentLanguage);
      
      // Also handle the load session language selector
      const loadLanguageSelect = document.getElementById('load-language-select');
      if (loadLanguageSelect) {
        loadLanguageSelect.addEventListener('change', (e) => {
          currentLanguage = e.target.value;
          updateUILanguage(currentLanguage);
        });
      }
    });
  </script>
</body>
</html>