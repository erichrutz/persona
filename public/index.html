<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Persona - Advanced Character Simulation</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Add Marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add highlight.js for code syntax highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/highlight.min.js"></script>
  <!-- Add localization support -->
  <script>
    // Initialize fallback localization immediately
    window.localization = {
      english: {
        app_subtitle: "Immersive Character Experience",
        new_session_btn: "New Session",
        load_session_btn: "Load Session",
        previous_chats_btn: "Previous Chats",
        previous_chats_title: "Previous Chats"
      },
      deutsch: {
        app_subtitle: "Immersive Charakter Erfahrung",
        new_session_btn: "Neue Sitzung",
        load_session_btn: "Sitzung laden",
        previous_chats_btn: "Frühere Chats",
        previous_chats_title: "Frühere Chats"
      }
    };

    // Try to load full localization.js dynamically
    (function() {
      const script = document.createElement('script');
      script.src = window.location.origin + '/localization.js';
      script.onerror = function() {
        console.warn('Could not load localization.js from same origin - trying with server config');
        // Try loading from configured server if different
        if (window.ServerConfig && window.ServerConfig.serverUrl !== window.location.origin) {
          const fallbackScript = document.createElement('script');
          fallbackScript.src = window.ServerConfig.serverUrl + '/localization.js';
          fallbackScript.onerror = function() {
            console.warn('Could not load localization.js from configured server - using fallback');
          };
          document.head.appendChild(fallbackScript);
        }
      };
      document.head.appendChild(script);
    })();
  </script>
  
  <!-- Server Configuration -->
  <script>
    // Server Configuration - Can be customized for remote deployment
    window.ServerConfig = {
      // Default to same origin, can be changed to remote server
      serverUrl: window.location.origin,
      
      // Method to build API URLs
      buildApiUrl: function(endpoint) {
        return this.serverUrl + endpoint;
      },
      
      // Load configuration from localStorage if available
      loadConfig: function() {
        const saved = localStorage.getItem('serverConfig');
        if (saved) {
          try {
            const config = JSON.parse(saved);
            this.serverUrl = config.serverUrl || window.location.origin;
          } catch (e) {
            console.warn('Failed to load server config from localStorage:', e);
          }
        }
      },
      
      // Save configuration to localStorage
      saveConfig: function() {
        localStorage.setItem('serverConfig', JSON.stringify({
          serverUrl: this.serverUrl
        }));
      },
      
      // Update server URL and save
      setServerUrl: function(url) {
        // Remove trailing slash
        this.serverUrl = url.replace(/\/$/, '');
        this.saveConfig();
      },
      
      // Enhanced fetch that includes credentials for cross-origin requests
      fetchWithCredentials: function(url, options = {}) {
        const isCurrentOrigin = url.startsWith(window.location.origin);
        const enhancedOptions = {
          ...options,
          credentials: isCurrentOrigin ? 'same-origin' : 'include'
        };
        
        // Debug logging
        if (!isCurrentOrigin) {
          console.log(`Making cross-origin request to: ${url}`);
          console.log(`Credentials mode: include`);
        }
        
        return fetch(url, enhancedOptions);
      },
      
      // Update placeholder images based on server configuration
      updatePlaceholderImages: function() {
        // Update any inline styles
        const elementsWithInlineStyles = document.querySelectorAll('[style*="/api/placeholder/"]');
        elementsWithInlineStyles.forEach(element => {
          const style = element.getAttribute('style');
          if (style && style.includes('/api/placeholder/')) {
            const newStyle = style.replace(
              /\/api\/placeholder\//g, 
              `${this.serverUrl}/api/placeholder/`
            );
            element.setAttribute('style', newStyle);
          }
        });
        
        // Also update any CSS classes that might have background images
        // This is a more robust approach for CSS-defined background images
        const allElements = document.querySelectorAll('*');
        allElements.forEach(element => {
          const computedStyle = window.getComputedStyle(element);
          const bgImage = computedStyle.backgroundImage;
          if (bgImage && bgImage.includes('/api/placeholder/')) {
            // Override with inline style pointing to configured server
            const newBgImage = bgImage.replace(
              /\/api\/placeholder\//g, 
              `${this.serverUrl}/api/placeholder/`
            );
            element.style.backgroundImage = newBgImage;
          }
        });
      }
    };
    
    // Load configuration on page load
    window.ServerConfig.loadConfig();
    
    // Update placeholder images when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      window.ServerConfig.updatePlaceholderImages();
    });
  </script>
  <style>
    :root {
      --primary-color: #4A90E2;
      --secondary-color: #f8f9fa;
      --accent-color: #357ABD;
      --text-color: #2c3e50;
      --light-accent: #E8F4FD;
      --dark-accent: #2E5F8F;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
      --border-radius: 12px;
      --card-shadow: 0 4px 16px rgba(74, 144, 226, 0.12);
      --background-color: #f0f4f8;
      --card-bg-color: rgba(255, 255, 255, 0.98);
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text-color);
      background-color: var(--background-color);
      line-height: 1.6;
      background-image: linear-gradient(135deg, rgba(74, 144, 226, 0.03) 25%, transparent 25%, transparent 50%, rgba(74, 144, 226, 0.03) 50%, rgba(74, 144, 226, 0.03) 75%, transparent 75%);
      background-size: 40px 40px;
    }
    
    .navbar {
      background-color: var(--card-bg-color);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(5px);
      border-bottom: 1px solid rgba(74, 144, 226, 0.1);
    }
    
    .navbar-brand {
      font-weight: 600;
      color: var(--primary-color);
      font-size: 1.5rem;
    }
    
    .app-subtitle {
      font-size: 0.9rem;
      color: #666;
      font-weight: normal;
    }
    
    .btn-primary {
      background-color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .btn-primary:hover {
      background-color: var(--dark-accent);
      border-color: var(--dark-accent);
    }
    
    .btn-outline-primary {
      color: var(--primary-color);
      border-color: var(--primary-color);
    }
    
    .btn-outline-primary:hover {
      background-color: var(--primary-color);
      color: white;
    }
    
    .card {
      border-radius: var(--border-radius);
      border: none;
      box-shadow: var(--card-shadow);
      overflow: hidden;
      background-color: var(--card-bg-color);
      backdrop-filter: blur(10px);
      transition: transform 0.2s, box-shadow 0.3s;
    }
    
    .card:hover {
      box-shadow: 0 6px 20px rgba(74, 144, 226, 0.18);
    }
    
    .card-header {
      background-color: rgba(255, 255, 255, 0.8);
      border-bottom: 1px solid rgba(74, 144, 226, 0.1);
      padding: 1rem 1.5rem;
      font-weight: 600;
      color: var(--dark-accent);
    }
    
    .session-info-card {
      background-color: white;
      border-radius: var(--border-radius);
      padding: 12px 20px;
      margin-bottom: 20px;
      box-shadow: var(--card-shadow);
    }
    
    .chat-container {
      height: calc(100vh - 320px);
      min-height: 500px;
      overflow-y: auto;
      padding: 1.5rem;
      background-color: #ffffff;
    }
    
    .message {
      margin-bottom: 20px;
      max-width: 85%;
      position: relative;
    }
    
    .user-message {
      background-color: var(--light-accent);
      color: var(--text-color);
      padding: 14px 20px;
      border-radius: 18px 18px 4px 18px;
      margin-left: auto;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border-top: 1px solid rgba(255, 255, 255, 0.5);
      border-left: 1px solid rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(4px);
    }
    
    .assistant-message {
      background-color: rgba(255, 255, 255, 0.85);
      color: var(--text-color);
      padding: 14px 20px;
      border-radius: 18px 18px 18px 4px;
      margin-right: auto;
      border: 1px solid rgba(74, 144, 226, 0.15);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(4px);
    }
    
    .system-message {
      background-color: rgba(0, 0, 0, 0.03);
      text-align: center;
      font-style: italic;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.85rem;
      color: #666;
      margin: 15px auto;
      max-width: 90%;
    }
    
    .message-avatar {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      margin-right: 12px;
    }
    
    .message-container {
      display: flex;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    
    .message-bubble {
      max-width: calc(100% - 50px);
    }

    .message-date-badge {
      font-size: 0.7rem;
      color: #6c757d;
      background-color: rgba(108, 117, 125, 0.08);
      padding: 3px 10px;
      border-radius: 12px;
      margin-bottom: 6px;
      margin-right: 6px;
      display: inline-block;
      font-weight: 500;
      letter-spacing: 0.3px;
      border: 1px solid rgba(108, 117, 125, 0.15);
    }

    .message-location-badge {
      font-size: 0.7rem;
      color: #20c997;
      background-color: rgba(32, 201, 151, 0.08);
      padding: 3px 10px;
      border-radius: 12px;
      margin-bottom: 6px;
      margin-right: 6px;
      display: inline-block;
      font-weight: 500;
      letter-spacing: 0.3px;
      border: 1px solid rgba(32, 201, 151, 0.15);
    }

    .message-clothing-badge {
      font-size: 0.7rem;
      color: #9B59B6;
      background-color: rgba(155, 89, 182, 0.08);
      padding: 3px 10px;
      border-radius: 12px;
      margin-bottom: 6px;
      margin-right: 6px;
      display: inline-block;
      font-weight: 500;
      letter-spacing: 0.3px;
      border: 1px solid rgba(155, 89, 182, 0.15);
    }

    .message-metadata-container {
      margin-bottom: 8px;
    }

    .message-input-container {
      background-color: rgba(255, 255, 255, 0.8);
      border-top: 1px solid rgba(74, 144, 226, 0.1);
      padding: 18px;
      border-radius: 0 0 var(--border-radius) var(--border-radius);
      backdrop-filter: blur(5px);
    }
    
    .message-input {
      border-radius: 24px;
      padding: 14px 24px;
      resize: none;
      border: 1px solid rgba(74, 144, 226, 0.2);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      transition: all 0.3s ease;
      min-height: 54px;
      max-height: 150px;
      background-color: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(4px);
      font-size: 1rem;
    }

    .message-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 3px 10px rgba(74, 144, 226, 0.2);
      outline: none;
      background-color: white;
    }
    
    .send-button {
      border-radius: 50%;
      width: 54px;
      height: 54px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: var(--primary-color);
      border-color: var(--primary-color);
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
      transition: all 0.3s ease;
    }

    .send-button:hover {
      background-color: var(--dark-accent);
      border-color: var(--dark-accent);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(74, 144, 226, 0.4);
    }
    
    .character-selection {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .character-card {
      border-radius: var(--border-radius);
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      height: 100%;
    }
    
    .character-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }
    
    .character-card.selected {
      border: 2px solid var(--primary-color);
    }
    
    .character-img {
      height: 160px;
      background-size: cover;
      background-position: center;
    }
    
    .char-detective {
      background-image: url('/api/placeholder/300/160');
      background-color: #4a6572;
      position: relative;
      overflow: hidden;
    }
    
    .char-mentor {
      background-image: url('/api/placeholder/300/160');
      background-color: #617c58;
      position: relative;
      overflow: hidden;
    }
    
    .char-therapist {
      background-image: url('/api/placeholder/300/160');
      background-color: #81a4cd;
      position: relative;
      overflow: hidden;
    }
    
    .char-coach {
      background-image: url('/api/placeholder/300/160');
      background-color: #b57e50;
      position: relative;
      overflow: hidden;
    }
    
    .char-creative {
      background-image: url('/api/placeholder/300/160');
      background-color: #a45c94;
      position: relative;
      overflow: hidden;
    }
    
    .char-custom {
      background-image: url('/api/placeholder/300/160');
      background-color: #8e7cc3;
      position: relative;
      overflow: hidden;
    }
    
    .character-img::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0) 60%, rgba(74, 144, 226, 0.6) 100%);
      z-index: 1;
    }
    
    .character-info {
      padding: 15px;
    }
    
    .memory-container {
      height: calc(100vh - 400px);
      min-height: 300px;
      overflow-y: auto;
      padding: 0.5rem;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-color) rgba(0,0,0,0.05);
    }
    
    .memory-container::-webkit-scrollbar {
      width: 8px;
    }
    
    .memory-container::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.05);
      border-radius: 4px;
    }
    
    .memory-container::-webkit-scrollbar-thumb {
      background-color: var(--accent-color);
      border-radius: 4px;
    }
    
    .memory-container::-webkit-scrollbar-thumb:hover {
      background-color: var(--dark-accent);
    }
    
    .memory-item {
      padding: 12px 18px;
      border-radius: 10px;
      margin-bottom: 10px;
      background-color: rgba(248, 249, 250, 0.8);
      border-left: 3px solid var(--primary-color);
      font-size: 0.9rem;
      transition: all 0.3s ease;
      position: relative;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    
    .memory-item:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 4px 10px rgba(233, 78, 119, 0.15);
      background-color: white;
      z-index: 2;
    }
    
    .memory-item.compressed {
      background-color: #f0f0ff;
      border-left-color: var(--accent-color);
    }
    
    .memory-item.high-importance {
      border-left-width: 5px;
      border-left-color: #9370db;
      background-color: rgba(147, 112, 219, 0.05);
    }
    
    .memory-item.medium-importance {
      border-left-width: 4px;
    }
    
    .memory-item.low-importance {
      border-left-color: rgba(106, 90, 205, 0.5);
      opacity: 0.9;
    }
    
    .memory-group-header {
      padding: 8px 5px;
      margin-top: 10px;
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 0.85rem;
      border-bottom: 1px solid #eee;
    }
    
    .memory-metadata {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #666;
      border-top: 1px solid #eee;
      padding-top: 6px;
    }
    
    .tooltip-text {
      visibility: hidden;
      width: 350px;
      background-color: rgba(33, 33, 33, 0.95);
      color: white;
      text-align: left;
      border-radius: 12px;
      padding: 15px;
      position: fixed; /* Changed from absolute to fixed */
      z-index: 9999; /* Higher z-index to ensure it's always on top */
      opacity: 0;
      transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      max-height: 80vh; /* Use viewport height instead of fixed pixels */
      overflow-y: auto;
      transform: translateY(10px);
      pointer-events: auto; /* Enable scrolling */
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    /* We now use JS event listeners instead */
    .tooltip-visible {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Custom scrollbar for tooltip */
    .tooltip-text::-webkit-scrollbar {
      width: 6px;
    }
    
    .tooltip-text::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    
    .tooltip-text::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    
    .tooltip-text::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    /* Add special styling for the memory content */
    .memory-content {
      position: relative;
      z-index: 1;
    }
    
    .compression-stats {
      font-size: 0.85rem;
      color: #666;
    }
    
    .progress {
      height: 6px;
      border-radius: 3px;
      margin: 8px 0;
    }
    
    .form-floating > label {
      padding: 0.75rem 1.25rem;
    }
    
    .form-floating > .form-control {
      padding: 1.25rem 1rem;
    }
    
    /* History panel styling */
    .history-entry {
      border-left: 3px solid var(--primary-color);
      margin-bottom: 12px;
      transition: all 0.2s ease;
    }
    
    .history-entry:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 10px rgba(233, 78, 119, 0.12);
    }
    
    #relationship-history .list-group-item {
      border-left: 3px solid var(--primary-color);
      transition: all 0.2s ease;
    }
    
    #relationship-history .list-group-item:hover {
      background-color: rgba(233, 78, 119, 0.05);
    }
    
    #history-tab.text-primary {
      position: relative;
    }
    
    #history-tab.text-primary::after {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: var(--primary-color);
      border-radius: 50%;
      right: -2px;
      top: 0;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(0.95); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(0.95); opacity: 1; }
    }
    
    .welcome-message {
      text-align: center;
      padding: 2rem;
    }
    
    .welcome-message h2 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }
    
    /* For better mobile experience */
    @media (max-width: 768px) {
      .message {
        max-width: 90%;
      }

      .character-selection {
        grid-template-columns: 1fr;
      }
    }

    /* Session Manager Styles */
    #sessionManagerModal .card {
      transition: all 0.3s ease;
      border: 1px solid rgba(74, 144, 226, 0.1);
    }

    #sessionManagerModal .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 144, 226, 0.15);
      border-color: rgba(74, 144, 226, 0.3);
    }

    #sessionManagerModal .card-body {
      padding: 1.25rem;
    }

    #session-search {
      border: 1px solid rgba(74, 144, 226, 0.2);
      transition: all 0.3s ease;
    }

    #session-search:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 0.2rem rgba(74, 144, 226, 0.15);
    }

    .input-group-text {
      background-color: rgba(74, 144, 226, 0.05);
      border: 1px solid rgba(74, 144, 226, 0.2);
      color: var(--primary-color);
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-light py-3">
    <div class="container-fluid px-4" style="max-width: 1600px;">
      <a class="navbar-brand d-flex align-items-center" href="#">
        <i class="fas fa-heart me-2" style="color: var(--primary-color);"></i>
        Persona <span class="app-subtitle ms-2" data-i18n="app_subtitle">Immersive Character Experience</span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item">
            <button id="new-session-btn" class="btn btn-outline-primary me-2">
              <i class="fas fa-plus-circle me-1"></i> <span data-i18n="new_session_btn">New Session</span>
            </button>
          </li>
          <li class="nav-item">
            <button id="load-session-btn" class="btn btn-outline-primary me-2">
              <i class="fas fa-folder-open me-1"></i> <span data-i18n="load_session_btn">Load Session</span>
            </button>
          </li>
          <li class="nav-item">
            <button id="previous-chats-btn" class="btn btn-outline-primary me-2" data-bs-toggle="modal" data-bs-target="#sessionManagerModal">
              <i class="fas fa-history me-1"></i> <span data-i18n="previous_chats_btn">Previous Chats</span>
            </button>
          </li>
          <li class="nav-item">
            <button id="character-creator-btn" class="btn btn-outline-primary me-2" data-bs-toggle="modal" data-bs-target="#characterCreatorModal">
              <i class="fas fa-wand-magic-sparkles me-1"></i> Character Creator
            </button>
          </li>
          <li class="nav-item">
            <button id="server-config-btn" class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#serverConfigModal">
              <i class="fas fa-server me-1"></i> Server
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container-fluid px-4 my-4" style="max-width: 1600px;">
    <!-- Session Info Card -->
    <div id="session-info-card" class="session-info-card d-flex justify-content-between align-items-center" style="display: none;">
      <div>
        <span id="session-info" class="fw-semibold" data-i18n="no_active_session">No active session</span>
        <span class="text-muted ms-2 small" id="save-status"></span>
      </div>
      <button id="save-session-btn" class="btn btn-sm btn-primary" disabled>
        <i class="fas fa-save me-1"></i> <span data-i18n="save_session_btn">Save Session</span>
      </button>
    </div>
    
    <!-- Setup Container -->
    <div id="setup-container">
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span data-i18n="create_simulation_title">Create Your Simulation</span>
        </div>
        <div class="card-body">
          <!-- API Key Input -->
          <div class="form-floating mb-3">
            <input type="password" class="form-control" id="api-key" placeholder="Enter your API key" data-i18n-placeholder="api_key_placeholder">
            <label for="api-key" data-i18n="api_key_label">Anthropic API Key (Optional)</label>
            <div class="form-text" data-i18n="api_key_help">Leave blank to use the server's default API key if configured.</div>
          </div>
          
          <!-- Character Selection Dropdown -->
          <div class="mb-4">
            <label for="character-select" class="form-label fw-bold" data-i18n="select_character_label">Select Character</label>
            <select class="form-select form-select-lg" id="character-select">
              <option value="" selected disabled data-i18n="select_character_placeholder">Choose a character to simulate...</option>
              <option value="custom" data-i18n="character_custom">Custom Character - Create your own</option>
            </select>
            <div class="form-text" data-i18n="character_select_help">Select a character for your conversation simulation.</div>
          </div>
          
          <!-- Character Description Panel -->
          <div class="card mb-4" id="character-description-panel" style="display: none;">
            <div class="card-body">
              <div class="row align-items-center">
                <div class="col-md-3 text-center mb-3 mb-md-0">
                  <div id="character-preview" class="rounded-circle mx-auto" style="width: 100px; height: 100px; background-color: var(--primary-color);"></div>
                </div>
                <div class="col-md-9">
                  <h5 id="character-title" class="card-title">Character Name</h5>
                  <p id="character-description" class="card-text">Character description will appear here.</p>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Custom Character Configuration -->
          <div id="custom-character-container" class="mt-4" style="display: none;">
            <div class="card">
              <div class="card-header">Custom Character Profile</div>
              <div class="card-body">
                <div class="form-floating mb-3">
                  <textarea class="form-control" id="custom-profile" rows="5" style="height: 150px"></textarea>
                  <label for="custom-profile">Custom Character Profile (JSON)</label>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Starting Scenario -->
          <div class="mt-4">
            <div class="form-floating mb-3">
              <textarea class="form-control" id="start-scenario" rows="3" style="height: 100px"></textarea>
              <label for="start-scenario">Starting Scenario (Optional)</label>
              <div class="form-text">Describe the initial context for your conversation with the character.</div>
            </div>
          </div>
          
          <!-- Deep Memory Configuration -->
          <div class="card mt-3">
            <div class="card-header">Deep Memory</div>
            <div class="card-body">
              <div class="form-floating mb-3">
                <textarea class="form-control" id="deep-memory" rows="3" style="height: 100px"></textarea>
                <label for="deep-memory">Persistent Deep Memory</label>
                <div class="form-text">Add important information that will never be compressed or forgotten. This will always be included with each prompt.</div>
              </div>
            </div>
          </div>

          <!-- Advanced Options -->
          <div class="card mt-3">
            <div class="card-header">Advanced Options</div>
            <div class="card-body">
              <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" id="enable-compression" checked>
                <label class="form-check-label" for="enable-compression">Enable Memory Compression</label>
                <div class="form-text">Periodically summarizes conversation history to optimize performance.</div>
              </div>
              
              <div class="mb-3">
                <label for="model-select" class="form-label">Model</label>
                <select class="form-select" id="model-select">
                  <option value="claude-sonnet-4-5-20250929" selected>Claude 4.5 Sonnet</option>
                  <option value="claude-3-7-sonnet-20250219" selected>Claude 3.7 Sonnet</option>
                  <option value="claude-3-5-sonnet-20240620">Claude 3.5 Sonnet</option>
                  <option value="claude-3-opus-20240229">Claude 3 Opus</option>
                  <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
                  <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                </select>
                <div class="form-text">Select the Claude model to use for this character.</div>
              </div>
              
              <div class="mb-3">
                <label for="language-select" class="form-label" data-i18n="language_label">Language</label>
                <select class="form-select" id="language-select">
                  <option value="english" selected>English</option>
                  <option value="deutsch">Deutsch</option>
                </select>
                <div class="form-text" data-i18n="language_help">Select the language for your conversation with the character.</div>
              </div>
            </div>
          </div>
          
          <!-- Start Button -->
          <div class="mt-4 text-center">
            <button id="start-session" class="btn btn-primary btn-lg">
              <i class="fas fa-play-circle me-2"></i> <span data-i18n="start_session_btn">Start Session</span>
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Session Loading -->
    <div id="session-loader" style="display: none;">
      <div class="card">
        <div class="card-header" data-i18n="load_saved_session_title">Load Saved Session</div>
        <div class="card-body">
          <div class="mb-3">
            <label for="session-select" class="form-label" data-i18n="select_session_label">Select a saved session</label>
            <select class="form-select" id="session-select">
              <option value="" data-i18n="select_session_placeholder">Choose a session to continue...</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="load-api-key" class="form-label" data-i18n="load_api_key_label">API Key (if different from original)</label>
            <input type="password" class="form-control" id="load-api-key" placeholder="Enter API key if needed" data-i18n-placeholder="load_api_key_placeholder">
          </div>
          <div class="mb-3">
            <label for="load-model-select" class="form-label" data-i18n="load_model_label">Model (optional)</label>
            <select class="form-select" id="load-model-select">
              <option value="" data-i18n="use_original_model">Use original model</option>
              <option value="claude-sonnet-4-5-20250929">Claude 4.5 Sonnet</option>
              <option value="claude-3-7-sonnet-20250219">Claude 3.7 Sonnet</option>
              <option value="claude-3-5-sonnet-20240620">Claude 3.5 Sonnet</option>
              <option value="claude-3-opus-20240229">Claude 3 Opus</option>
              <option value="claude-3-sonnet-20240229">Claude 3 Sonnet</option>
              <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
            </select>
            <div class="form-text" data-i18n="load_model_help">Select a different model or leave as is to use the original.</div>
          </div>
          
          <div class="mb-3">
            <label for="load-language-select" class="form-label" data-i18n="language_label">Language</label>
            <select class="form-select" id="load-language-select">
              <option value="english" selected>English</option>
              <option value="deutsch">Deutsch</option>
            </select>
            <div class="form-text" data-i18n="language_help">Select the language for your conversation with the character.</div>
          </div>
          <div class="d-flex justify-content-between">
            <button id="cancel-load" class="btn btn-outline-secondary" data-i18n="cancel_btn">Cancel</button>
            <div>
              <button id="delete-session" class="btn btn-outline-danger me-2" data-i18n="delete_session_btn">Delete Session</button>
              <button id="load-session" class="btn btn-primary" data-i18n="load_session_confirm_btn">Load Session</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Chat Interface -->
    <div id="chat-container" class="row g-4" style="display: none;">
      <div class="col-lg-8">
        <div class="card h-100">
          <div class="card-header" style="padding: 0.75rem 1.25rem;">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="d-flex align-items-center">
                <span id="character-avatar" class="message-avatar d-inline-block me-2 bg-primary"></span>
                <span id="character-name" class="fw-semibold">Character Name</span>
                <div class="dropdown ms-2">
                  <span id="model-badge" class="badge bg-secondary small dropdown-toggle" style="font-size: 0.7rem; cursor: pointer;" data-bs-toggle="dropdown" aria-expanded="false"></span>
                  <ul class="dropdown-menu model-dropdown" aria-labelledby="model-badge">
                    <li><a class="dropdown-item model-option" data-model="claude-sonnet-4-5-20250929" href="#">Claude 4.5 Sonnet</a></li>
                    <li><a class="dropdown-item model-option" data-model="claude-3-7-sonnet-20250219" href="#">Claude 3.7 Sonnet</a></li>
                    <li><a class="dropdown-item model-option" data-model="claude-3-5-sonnet-20240620" href="#">Claude 3.5 Sonnet</a></li>
                    <li><a class="dropdown-item model-option" data-model="claude-3-opus-20240229" href="#">Claude 3 Opus</a></li>
                    <li><a class="dropdown-item model-option" data-model="claude-3-sonnet-20240229" href="#">Claude 3 Sonnet</a></li>
                    <li><a class="dropdown-item model-option" data-model="claude-3-haiku-20240307" href="#">Claude 3 Haiku</a></li>
                  </ul>
                </div>
              </div>
              <div>
                <button id="show-memory" class="btn btn-sm btn-outline-primary me-2">
                  <i class="fas fa-brain me-1"></i> <span data-i18n="memory_btn">Memory</span>
                </button>
                <button id="compress-memory" class="btn btn-sm btn-primary">
                  <i class="fas fa-compress-alt me-1"></i> <span data-i18n="compress_btn">Compress</span>
                </button>
              </div>
            </div>
            <div class="d-flex align-items-center" style="gap: 6px; min-height: 22px;">
              <span id="header-location-badge" class="message-location-badge" style="display: none; margin: 0; font-size: 0.65rem; padding: 2px 8px;"></span>
              <span id="header-clothing-badge" class="message-clothing-badge" style="display: none; margin: 0; font-size: 0.65rem; padding: 2px 8px;"></span>
            </div>
          </div>
          
          <!-- Welcome placeholder for empty chat -->
          <div id="welcome-placeholder" class="welcome-message">
            <h2 data-i18n="welcome_title">Welcome to Your Intimate Experience</h2>
            <p data-i18n="welcome_text">Your private conversation will appear here. Start by introducing yourself and sharing your desires.</p>
            <div class="welcome-image-container my-4" style="max-width: 300px; margin: 0 auto; position: relative; overflow: hidden; border-radius: 15px; box-shadow: 0 8px 20px rgba(74, 144, 226, 0.25);">
              <img src="/api/placeholder/300/200" alt="Welcome illustration" class="img-fluid" style="transform: scale(1.05); transition: transform 0.5s ease;">
              <div style="position: absolute; inset: 0; background: linear-gradient(to bottom, rgba(74, 144, 226, 0.1), rgba(74, 144, 226, 0.4)); backdrop-filter: blur(3px);"></div>
            </div>
          </div>
          
          <!-- Chat messages -->
          <div class="card-body chat-container" id="messages"></div>
          
          <!-- Message input -->
          <div class="message-input-container">
            <div class="input-group">
              <textarea id="message-input" class="form-control message-input" data-i18n-placeholder="message_placeholder" placeholder="Type your message... (Shift+Enter for new line)" rows="1"></textarea>
              <button id="send-message" class="btn btn-primary send-button">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Memory Panel -->
      <div class="col-lg-4" id="memory-panel" style="display: none;">
        <div class="card h-100">
          <div class="card-header" data-i18n="memory_system_title">Memory System</div>
          <div class="card-body d-flex flex-column h-100">
            <ul class="nav nav-tabs mb-3" id="memoryTabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="short-term-tab" data-bs-toggle="tab" data-bs-target="#short-term-content" type="button" role="tab" data-i18n="short_term_label">Short-Term</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="long-term-tab" data-bs-toggle="tab" data-bs-target="#long-term-content" type="button" role="tab" data-i18n="long_term_label">Long-Term</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="clothing-tab" data-bs-toggle="tab" data-bs-target="#clothing-content" type="button" role="tab">Clothing</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="location-tab" data-bs-toggle="tab" data-bs-target="#location-content" type="button" role="tab">Location</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="history-tab" data-bs-toggle="tab" data-bs-target="#history-content" type="button" role="tab">History</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="deep-memory-tab" data-bs-toggle="tab" data-bs-target="#deep-memory-content" type="button" role="tab" data-i18n="deep_memory_panel_label">Deep Memory</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats-content" type="button" role="tab" data-i18n="stats_label">Stats</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="character-profile-tab" data-bs-toggle="tab" data-bs-target="#character-profile-content" type="button" role="tab">Charakterprofil</button>
              </li>
            </ul>
            
            <div class="tab-content flex-grow-1">
              <!-- Short-Term Memory Tab -->
              <div class="tab-pane fade show active h-100" id="short-term-content" role="tabpanel">
                <div class="memory-container h-100">
                  <ul id="short-term-memory" class="list-unstyled"></ul>
                </div>
              </div>
              
              <!-- Long-Term Memory Tab -->
              <div class="tab-pane fade h-100" id="long-term-content" role="tabpanel">
                <div class="memory-container h-100">
                  <ul id="long-term-memory" class="list-unstyled"></ul>
                </div>
              </div>

              <!-- Clothing Tab -->
              <div class="tab-pane fade h-100" id="clothing-content" role="tabpanel">
                <div class="memory-container h-100">
                  <div class="card mb-3 bg-light">
                    <div class="card-body">
                      <h5 class="card-title">Character's Clothing</h5>
                      <p id="character-clothing" class="card-text">No information available</p>
                    </div>
                  </div>
                  <div class="card mb-3 bg-light">
                    <div class="card-body">
                      <h5 class="card-title">User's Clothing</h5>
                      <p id="user-clothing" class="card-text">No information available</p>
                    </div>
                  </div>
                  <div class="form-floating mb-3">
                    <textarea class="form-control" id="update-character-clothing" rows="2" style="height: 80px"></textarea>
                    <label for="update-character-clothing">Update Character's Clothing</label>
                  </div>
                  <div class="form-floating mb-3">
                    <textarea class="form-control" id="update-user-clothing" rows="2" style="height: 80px"></textarea>
                    <label for="update-user-clothing">Update User's Clothing</label>
                  </div>
                  <button id="save-clothing" class="btn btn-primary">
                    <i class="fas fa-save me-1"></i> Save Clothing Information
                  </button>
                </div>
              </div>
              
              <!-- Location Tab -->
              <div class="tab-pane fade h-100" id="location-content" role="tabpanel">
                <div class="memory-container h-100">
                  <div class="card mb-3 bg-light">
                    <div class="card-body">
                      <h5 class="card-title">Character's Location</h5>
                      <p id="character-location" class="card-text">No information available</p>
                    </div>
                  </div>
                  <div class="form-floating mb-3">
                    <textarea class="form-control" id="update-character-location" rows="3" style="height: 100px"></textarea>
                    <label for="update-character-location">Update Character's Location</label>
                  </div>
                  <button id="save-location" class="btn btn-primary">
                    <i class="fas fa-map-marker-alt me-1"></i> Save Location Information
                  </button>
                </div>
              </div>
              
              <!-- History Tab -->
              <div class="tab-pane fade h-100" id="history-content" role="tabpanel">
                <div class="memory-container h-100">
                  <div class="card mb-3">
                    <div class="card-header d-flex justify-content-between align-items-center">
                      <span>Relationship History</span>
                      <button id="refresh-history" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-sync-alt"></i> Refresh
                      </button>
                    </div>
                    <div class="card-body">
                      <p class="text-muted small mb-3">Significant relationship changes are tracked here, limited to 4 words each.</p>
                      <div class="d-flex justify-content-between align-items-center mb-2">
                        <div>
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="history-edit-mode">
                            <label class="form-check-label" for="history-edit-mode">Edit Mode</label>
                          </div>
                        </div>
                        <button id="delete-selected-history" class="btn btn-sm btn-danger" style="display: none;">
                          <i class="fas fa-trash-alt me-1"></i> Delete Selected
                        </button>
                      </div>
                      <ul id="relationship-history" class="list-group">
                        <li class="list-group-item text-center text-muted">No history entries yet</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Deep Memory Tab -->
              <div class="tab-pane fade h-100" id="deep-memory-content" role="tabpanel">
                <div class="memory-container h-100">
                  <div id="deep-memory-display" class="mb-3"></div>
                  <div class="form-floating mb-3">
                    <textarea class="form-control" id="update-deep-memory" rows="3" style="height: 100px"></textarea>
                    <label for="update-deep-memory">Update Deep Memory</label>
                  </div>
                  <button id="save-deep-memory" class="btn btn-primary">
                    <i class="fas fa-save me-1"></i> Save Deep Memory
                  </button>
                </div>
              </div>
              
              <!-- Compression Stats Tab -->
              <div class="tab-pane fade" id="stats-content" role="tabpanel">
                <div class="card-body">
                  <h6 class="card-title">Memory Compression</h6>
                  <div class="form-check form-switch mb-3">
                    <input class="form-check-input" type="checkbox" id="compression-toggle" checked>
                    <label class="form-check-label" for="compression-toggle">Enabled</label>
                  </div>
                  
                  <div class="compression-stats">
                    <p>API calls since last compression: <span id="api-call-count">0</span>/10</p>
                    <div class="progress mb-3">
                      <div id="compression-progress-bar" class="progress-bar bg-primary" role="progressbar" style="width: 0%"></div>
                    </div>

                    <p>Last compression: <span id="last-compression-time">Never</span></p>
                    <p>Compression count: <span id="compression-count">0</span></p>
                    <p>Last reduction: <span id="last-compression-ratio">N/A</span></p>
                    <p>Average reduction: <span id="avg-compression-ratio">N/A</span></p>

                    <button id="compress-now-btn" class="btn btn-sm btn-primary mt-2 mb-3">
                      <i class="fas fa-sync-alt me-1"></i> Compress Now
                    </button>

                    <!-- Token Usage Section -->
                    <h6 class="mt-4 mb-2">Token Usage</h6>
                    <div class="table-responsive">
                      <table class="table table-sm">
                        <tbody>
                          <tr>
                            <td>Total Tokens:</td>
                            <td class="text-end"><strong><span id="total-tokens">0</span></strong></td>
                          </tr>
                          <tr>
                            <td>Input Tokens:</td>
                            <td class="text-end"><span id="total-input-tokens">0</span></td>
                          </tr>
                          <tr>
                            <td>Output Tokens:</td>
                            <td class="text-end"><span id="total-output-tokens">0</span></td>
                          </tr>
                          <tr>
                            <td>Avg per Message:</td>
                            <td class="text-end"><span id="avg-tokens-per-msg">0</span></td>
                          </tr>
                          <tr>
                            <td>Peak Input:</td>
                            <td class="text-end"><span id="peak-input-tokens">0</span></td>
                          </tr>
                          <tr>
                            <td>Messages Processed:</td>
                            <td class="text-end"><span id="messages-processed">0</span></td>
                          </tr>
                        </tbody>
                      </table>
                    </div>

                    <!-- Memory Statistics Section -->
                    <h6 class="mt-4 mb-2">Memory Statistics</h6>
                    <div class="table-responsive">
                      <table class="table table-sm">
                        <tbody>
                          <tr>
                            <td>Memories Created:</td>
                            <td class="text-end"><span id="memories-created">0</span></td>
                          </tr>
                          <tr>
                            <td>Memories Compressed:</td>
                            <td class="text-end"><span id="memories-compressed">0</span></td>
                          </tr>
                          <tr>
                            <td>Current Long-Term:</td>
                            <td class="text-end"><span id="current-longterm">0</span></td>
                          </tr>
                          <tr>
                            <td>Short-Term:</td>
                            <td class="text-end"><span id="current-shortterm">0</span></td>
                          </tr>
                        </tbody>
                      </table>
                    </div>

                    <!-- Current State Section -->
                    <h6 class="mt-4 mb-2">Profile Sizes</h6>
                    <div class="table-responsive">
                      <table class="table table-sm">
                        <tbody>
                          <tr>
                            <td>Character Profile:</td>
                            <td class="text-end"><span id="char-profile-bytes">0</span> bytes</td>
                          </tr>
                          <tr>
                            <td>User Profile:</td>
                            <td class="text-end"><span id="user-profile-bytes">0</span> bytes</td>
                          </tr>
                          <tr>
                            <td>Deep Memory:</td>
                            <td class="text-end"><span id="deep-memory-length">0</span> chars</td>
                          </tr>
                        </tbody>
                      </table>
                    </div>

                    <!-- Topic Distribution Section -->
                    <h6 class="mt-4 mb-2">Topic Distribution</h6>
                    <div id="topic-distribution" class="small">
                      <em class="text-muted">No data yet</em>
                    </div>

                    <!-- Compression History Section -->
                    <h6 class="mt-4 mb-2">Recent Compressions</h6>
                    <div id="compression-history" class="small">
                      <em class="text-muted">No compressions yet</em>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Character Profile Tab -->
              <div class="tab-pane fade" id="character-profile-content" role="tabpanel">
                <div class="card-body">
                  <h6 class="card-title">Charakterprofil</h6>
                  <div id="character-profile-display" class="mb-3">
                    <pre class="bg-light p-3 rounded" style="white-space: pre-wrap; font-size: 0.9rem;"></pre>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Localization utility
    let currentLanguage = 'english'; // Default language
    
    function updateUILanguage(language) {
      // Safety check for localization object
      if (typeof localization === 'undefined' || !localization) {
        console.warn('Localization not yet loaded, retrying in 100ms...');
        setTimeout(() => updateUILanguage(language), 100);
        return;
      }
      
      // Set current language
      currentLanguage = language || 'english';
      document.documentElement.lang = currentLanguage === 'deutsch' ? 'de' : 'en';
      
      // Update document title if translation exists
      if (localization[currentLanguage] && localization[currentLanguage].page_title) {
        document.title = localization[currentLanguage].page_title;
      }
      
      // Update all elements with data-i18n attribute
      const elements = document.querySelectorAll('[data-i18n]');
      elements.forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (localization[currentLanguage] && localization[currentLanguage][key]) {
          element.textContent = localization[currentLanguage][key];
        }
      });
      
      // Update placeholders with data-i18n-placeholder attribute
      const placeholders = document.querySelectorAll('[data-i18n-placeholder]');
      placeholders.forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        if (localization[currentLanguage][key]) {
          element.placeholder = localization[currentLanguage][key];
        }
      });
      
      // Update help text with data-i18n-help attribute
      const helpText = document.querySelectorAll('[data-i18n-help]');
      helpText.forEach(element => {
        const key = element.getAttribute('data-i18n-help');
        if (localization[currentLanguage][key]) {
          element.textContent = localization[currentLanguage][key];
        }
      });
    }
    
    // Get text from localization
    function getText(key) {
      return localization[currentLanguage][key] || key;
    }

    // Helper function to escape HTML (global utility)
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Function to update model badge
      function updateModelBadge(model) {
        const modelBadge = document.getElementById('model-badge');
        if (!modelBadge) return;
        
        // Extract model name for display
        let displayName = model;
        
        // Format the model name for display
        if (model.includes('claude-3-7')) {
          displayName = 'Claude 3.7 Sonnet';
        } else if (model.includes('claude-4-5')) {
          displayName = 'Claude 4.5 Sonnet';
        } else if (model.includes('claude-3-5')) {
          displayName = 'Claude 3.5 Sonnet';
        } else if (model.includes('claude-3-opus')) {
          displayName = 'Claude 3 Opus';
        } else if (model.includes('claude-3-sonnet') && !model.includes('3-5') && !model.includes('3-7')) {
          displayName = 'Claude 3 Sonnet';
        } else if (model.includes('claude-3-haiku')) {
          displayName = 'Claude 3 Haiku';
        }
        
        modelBadge.textContent = displayName;
        modelBadge.style.display = 'inline-block';
      }
      // Set up model switching
      document.querySelectorAll('.model-option').forEach(option => {
        option.addEventListener('click', event => {
          event.preventDefault();
          if (!activeSessionId) return;
          
          const newModel = event.target.getAttribute('data-model');
          if (!newModel) return;
          
          // Update the model badge
          updateModelBadge(newModel);
          
          // Store the current model for next message
          currentModel = newModel;
          
          // Add system message about model change
          addSystemMessage(`Model switched to ${event.target.textContent}`);
        });
      });
      
      // Variable to store the currently selected model
      let currentModel = 'claude-3-7-sonnet-20250219';
      
      // Configure marked options for security and features
      marked.setOptions({
        gfm: true,
        breaks: true,
        sanitize: false,
        smartLists: true,
        smartypants: true,
        highlight: function(code, lang) {
          if (lang && hljs.getLanguage(lang)) {
            return hljs.highlight(code, { language: lang }).value;
          }
          return hljs.highlightAuto(code).value;
        }
      });
      
      // DOM elements
      const setupContainer = document.getElementById('setup-container');
      const sessionLoader = document.getElementById('session-loader');
      const chatContainer = document.getElementById('chat-container');
      const sessionInfoCard = document.getElementById('session-info-card');
      const welcomePlaceholder = document.getElementById('welcome-placeholder');
      const apiKeyInput = document.getElementById('api-key');
      const characterCards = document.querySelectorAll('.character-card');
      const customCharacterContainer = document.getElementById('custom-character-container');
      const customProfileInput = document.getElementById('custom-profile');
      const startSessionButton = document.getElementById('start-session');
      const characterNameElement = document.getElementById('character-name');
      const characterAvatar = document.getElementById('character-avatar');
      const messagesContainer = document.getElementById('messages');
      const messageInput = document.getElementById('message-input');
      const sendMessageButton = document.getElementById('send-message');
      const showMemoryButton = document.getElementById('show-memory');
      const compressMemoryButton = document.getElementById('compress-memory');
      const memoryPanel = document.getElementById('memory-panel');
      const headerLocationBadge = document.getElementById('header-location-badge');
      const headerClothingBadge = document.getElementById('header-clothing-badge');
      const shortTermMemoryList = document.getElementById('short-term-memory');
      const longTermMemoryList = document.getElementById('long-term-memory');
      const sessionInfoElement = document.getElementById('session-info');
      const saveStatusElement = document.getElementById('save-status');
      const newSessionButton = document.getElementById('new-session-btn');
      const loadSessionMenuButton = document.getElementById('load-session-btn');
      const saveSessionButton = document.getElementById('save-session-btn');
      const sessionSelectElement = document.getElementById('session-select');
      const loadApiKeyInput = document.getElementById('load-api-key');
      const loadSessionButton = document.getElementById('load-session');
      const deleteSessionButton = document.getElementById('delete-session');
      const cancelLoadButton = document.getElementById('cancel-load');
      const compressionToggle = document.getElementById('compression-toggle');
      const compressNowButton = document.getElementById('compress-now-btn');
      const apiCallCountElement = document.getElementById('api-call-count');
      const lastCompressionTimeElement = document.getElementById('last-compression-time');
      const compressionCountElement = document.getElementById('compression-count');
      const lastCompressionRatioElement = document.getElementById('last-compression-ratio');
      const compressionProgressBar = document.getElementById('compression-progress-bar');
      const enableCompressionCheckbox = document.getElementById('enable-compression');
      
      // Session state
      let activeSessionId = null;
      let selectedCharacterType = null;
      let lastSaveTime = null;
      let availableCharacters = [];
      let selectedCharacterData = null;
      
      // Load available characters from the server
      async function loadAvailableCharacters() {
        try {
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/characters'));
          availableCharacters = await response.json();
          
          // Populate the character dropdown
          const characterSelect = document.getElementById('character-select');
          if (characterSelect) {
            // Clear existing options except placeholder and custom
            const placeholder = characterSelect.querySelector('option[value=""]');
            const customOption = characterSelect.querySelector('option[value="custom"]');
            characterSelect.innerHTML = '';
            
            // Re-add placeholder and custom options
            if (placeholder) characterSelect.appendChild(placeholder);
            if (customOption) characterSelect.appendChild(customOption);
            
            // Add characters from files
            availableCharacters.forEach(character => {
              const option = document.createElement('option');
              option.value = character.filename;
              option.textContent = character.displayName;
              characterSelect.appendChild(option);
            });
          }
        } catch (error) {
          console.error('Error loading characters:', error);
        }
      }
      
      // Load character profile data
      async function loadCharacterProfile(filename) {
        try {
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/character/${filename}`));
          return await response.json();
        } catch (error) {
          console.error('Error loading character profile:', error);
          return null;
        }
      }
      
      // Handle character dropdown selection
      const characterSelect = document.getElementById('character-select');
      const characterDescriptionPanel = document.getElementById('character-description-panel');
      const characterTitle = document.getElementById('character-title');
      const characterDescription = document.getElementById('character-description');
      const characterPreview = document.getElementById('character-preview');
      
      if (characterSelect) {
        characterSelect.addEventListener('change', async () => {
          selectedCharacterType = characterSelect.value;
          
          // Show character description panel
          if (characterDescriptionPanel) {
            characterDescriptionPanel.style.display = 'block';
          }
          
          // Handle custom character
          if (selectedCharacterType === 'custom') {
            if (characterTitle && characterDescription && characterPreview) {
              characterTitle.textContent = 'Custom Character';
              characterDescription.textContent = 'Create your own unique character with custom personality traits, background, and expertise.';
              characterPreview.style.backgroundColor = '#8e7cc3';
            }
            customCharacterContainer.style.display = 'block';
            selectedCharacterData = null;
            return;
          }
          
          // Hide custom character container for file-based characters
          customCharacterContainer.style.display = 'none';
          
          // Load character profile from file
          if (selectedCharacterType && selectedCharacterType !== '') {
            selectedCharacterData = await loadCharacterProfile(selectedCharacterType);
            
            if (selectedCharacterData && characterTitle && characterDescription && characterPreview) {
              // Find the character info from the available characters list
              const characterInfo = availableCharacters.find(char => char.filename === selectedCharacterType);
              
              if (characterInfo) {
                characterTitle.textContent = characterInfo.displayName;
                
                // Try to extract description from character content
                let description = 'Character profile loaded from file.';
                if (selectedCharacterData.content) {
                  // For symbolic text files, look for DESCRIPTION: or PERSONALITY: sections
                  const descMatch = selectedCharacterData.content.match(/(?:DESCRIPTION|PERSONALITY):[ \t]*(.*?)(?=\n\s*[A-Z]+:|$)/is);
                  if (descMatch) {
                    description = descMatch[1].trim().split('\n')[0]; // Take first line
                  }
                }
                
                characterDescription.textContent = description;
                characterPreview.style.backgroundColor = '#4a6572'; // Default color for file-based characters
              }
            }
          }
        });
      }
      
      // Auto-resize textarea as user types
      messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
      });
      
      // New session button
      newSessionButton.addEventListener('click', () => {
        setupContainer.style.display = 'block';
        sessionLoader.style.display = 'none';
        chatContainer.style.display = 'none';
        sessionInfoCard.style.display = 'none';
      });
      
      // Load session menu button
      loadSessionMenuButton.addEventListener('click', async () => {
        setupContainer.style.display = 'none';
        chatContainer.style.display = 'none';
        sessionLoader.style.display = 'block';
        
        // Fetch available sessions
        try {
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/sessions'));
          const sessions = await response.json();
          
          // Clear previous options
          sessionSelectElement.innerHTML = '<option value="">Select a saved session...</option>';
          
          // Add sessions to dropdown
          sessions.forEach(session => {
            const option = document.createElement('option');
            option.value = session.sessionId;
            option.textContent = `${session.characterName} - ${new Date(session.timestamp).toLocaleString()}`;
            sessionSelectElement.appendChild(option);
          });
        } catch (error) {
          alert(`Error loading sessions: ${error.message}`);
        }
      });
      
      // Cancel load button
      cancelLoadButton.addEventListener('click', () => {
        sessionLoader.style.display = 'none';
        
        // Show appropriate container based on current state
        if (activeSessionId) {
          chatContainer.style.display = 'block';
          sessionInfoCard.style.display = 'flex';
        } else {
          setupContainer.style.display = 'block';
        }
      });
      
      // Load selected session
      loadSessionButton.addEventListener('click', async () => {
        const sessionId = sessionSelectElement.value;
        if (!sessionId) {
          alert('Please select a session to load');
          return;
        }
        
        try {
          // Load the session
          // Get the selected model if any
          const loadModelSelect = document.getElementById('load-model-select');
          const selectedLoadModel = loadModelSelect ? loadModelSelect.value : '';
          
          // Get selected language
          const loadLanguageSelect = document.getElementById('load-language-select');
          const selectedLanguage = loadLanguageSelect ? loadLanguageSelect.value : 'english';
          
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/session'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sessionId: sessionId,
              apiKey: loadApiKeyInput.value.trim() || null,
              model: selectedLoadModel || undefined,
              language: selectedLanguage
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Update UI
            activeSessionId = data.sessionId;
            characterNameElement.textContent = data.characterName;
            sessionInfoElement.textContent = `Active session: ${data.characterName}`;
            saveStatusElement.textContent = 'Auto-saving enabled';
            saveSessionButton.disabled = false;
            
            // Set character avatar background color
            setCharacterAvatar(data.characterType);
            
            // Hide setup and show chat
            setupContainer.style.display = 'none';
            sessionLoader.style.display = 'none';
            chatContainer.style.display = 'flex';
            sessionInfoCard.style.display = 'flex';
            
            // Hide welcome placeholder if messages exist
            welcomePlaceholder.style.display = 'none';
            
            // Clear messages and add welcome back message
            messagesContainer.innerHTML = '';
            addSystemMessage(`Session loaded! Continue your conversation with ${data.characterName}.`);
            
            // Update model badge if available
            const modelBadge = document.getElementById('model-badge');
            if (modelBadge && data.model) {
              updateModelBadge(data.model);
            }
            
            // Update memory display if visible
            if (memoryPanel.style.display !== 'none') {
              updateMemoryDisplay(data.memoryState);
            }

            // Update header badges with current location and clothing
            if (data.memoryState) {
              updateHeaderBadges(data.memoryState.location, data.memoryState.clothing);
            }

            // Update compression toggle
            if (compressionToggle && data.memoryState && data.memoryState.compressionEnabled !== undefined) {
              compressionToggle.checked = data.memoryState.compressionEnabled;
            }

            // Update compression stats
            updateCompressionStats();
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error loading session: ${error.message}`);
        }
      });
      
      // Delete selected session
      deleteSessionButton.addEventListener('click', async () => {
        const sessionId = sessionSelectElement.value;
        if (!sessionId) {
          alert('Please select a session to delete');
          return;
        }
        
        if (!confirm('Are you sure you want to delete this session? This cannot be undone.')) {
          return;
        }
        
        try {
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/session/${sessionId}`), {
            method: 'DELETE'
          });
          
          const data = await response.json();
          
          if (response.ok) {
            alert('Session deleted successfully');
            
            // Remove from dropdown
            const option = sessionSelectElement.querySelector(`option[value="${sessionId}"]`);
            if (option) {
              option.remove();
            }
            
            // If it was the active session, reset state
            if (activeSessionId === sessionId) {
              activeSessionId = null;
              sessionInfoElement.textContent = 'No active session';
              saveStatusElement.textContent = '';
              saveSessionButton.disabled = true;
              
              // Show setup
              sessionLoader.style.display = 'none';
              chatContainer.style.display = 'none';
              sessionInfoCard.style.display = 'none';
              setupContainer.style.display = 'block';
            }
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error deleting session: ${error.message}`);
        }
      });
      
      // Start new session
      startSessionButton.addEventListener('click', async () => {
        const characterSelect = document.getElementById('character-select');
        selectedCharacterType = characterSelect ? characterSelect.value : selectedCharacterType;
        
        if (!selectedCharacterType) {
          alert('Please select a character type');
          return;
        }
        
        const apiKey = apiKeyInput.value.trim();
        const startScenario = document.getElementById('start-scenario').value.trim();
        const compressionEnabled = enableCompressionCheckbox.checked;
        
        // Get selected model
        const modelSelect = document.getElementById('model-select');
        const selectedModel = modelSelect ? modelSelect.value : 'claude-3-7-sonnet-20250219';
        
        // Get deep memory if provided
        const deepMemory = document.getElementById('deep-memory').value.trim();
        
        // Get selected language
        const languageSelect = document.getElementById('language-select');
        const selectedLanguage = languageSelect ? languageSelect.value : 'english';
        
        // Prepare request data
        const requestData = {
          characterType: selectedCharacterType,
          apiKey: apiKey || null,
          startScenario: startScenario,
          compressionEnabled: compressionEnabled,
          deepMemory: deepMemory,
          model: selectedModel,
          language: selectedLanguage
        };
        
        // Add custom profile if selected or character data from file
        if (selectedCharacterType === 'custom') {
          try {
            requestData.customProfile = JSON.parse(customProfileInput.value);
          } catch (error) {
            requestData.customProfile = customProfileInput.value;
            //alert('Invalid JSON for custom character profile');
            // return;
          }
        } else if (selectedCharacterData && selectedCharacterData.content) {
          // Use character data from file
          requestData.customProfile = selectedCharacterData.content;
          requestData.characterType = 'custom'; // Treat file-based characters as custom
        }
        
        try {
          // Create session
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/session'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Save session ID
            activeSessionId = data.sessionId;
            
            // Update UI
            characterNameElement.textContent = data.characterName;
            sessionInfoElement.textContent = `Active session: ${data.characterName}`;
            saveStatusElement.textContent = 'Auto-saving enabled';
            saveSessionButton.disabled = false;
            
            // Set character avatar background color
            setCharacterAvatar(selectedCharacterType);
            
            // Update model badge
            const modelBadge = document.getElementById('model-badge');
            if (modelBadge) {
              updateModelBadge(selectedModel);
            }
                        
            // Set compression toggle state
            if (compressionToggle) {
              compressionToggle.checked = compressionEnabled;
            }
            
            setupContainer.style.display = 'none';
            chatContainer.style.display = 'flex';
            sessionInfoCard.style.display = 'flex';
            
            // Hide welcome after first message
            welcomePlaceholder.style.display = 'block';
            
            // Add welcome message
            addSystemMessage(`Connected! You are now chatting with ${data.characterName}. Try asking about their appearance, background, or how they can help you.`);
                        
            // Initialize compression stats
            updateCompressionStats();
          } else {
            alert(`Error: ${data.error}`);
          }
        } catch (error) {
          alert(`Error starting session: ${error.message}`);
        }
      });
      
      // Send message
      sendMessageButton.addEventListener('click', sendMessage);
      
      // Handle Enter and Shift+Enter in the message input
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          // If Shift key is pressed with Enter, allow default behavior (new line)
          if (!e.shiftKey) {
            e.preventDefault(); // Prevent default Enter behavior (which is new line)
            sendMessage(); // Send the message
          }
        }
      });
      
      async function sendMessage() {
        const message = messageInput.value.trim();
        console.log('SendMessage: activeSessionId =', activeSessionId);
        console.log('SendMessage: message =', message);
        if (!message || !activeSessionId) return;
        
        // Hide welcome placeholder when first message is sent
        welcomePlaceholder.style.display = 'none';
        
        // Add user message to UI
        addUserMessage(message);
        messageInput.value = '';
        messageInput.style.height = 'auto';
        
        try {
          // Update save status
          saveStatusElement.textContent = 'Sending message...';
          
          // Send message to server
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/message'), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sessionId: activeSessionId,
              message,
              model: currentModel // Send the currently selected model
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Add assistant response to UI with date, location, and clothing badges
            addAssistantMessage(data.response, data.date, data.location, data.clothing);

            // Update header badges with current location and clothing
            updateHeaderBadges(data.location, data.clothing);

            // Update memory display if visible
            if (memoryPanel.style.display !== 'none') {
              updateMemoryDisplay(data.memoryState, data.characterProfile);
            }
            
            // Check if any history updates were detected in the response
            if (data.historyUpdated) {
              // Fetch updated history data
              fetchRelationshipHistory();
              
              // Add a subtle indicator that relationship history was updated
              const historyTab = document.getElementById('history-tab');
              if (historyTab) {
                // Add a visual indicator that there's new history
                historyTab.classList.add('text-primary', 'fw-bold');
                // Remove indicator when tab is clicked
                historyTab.addEventListener('click', function onceHandler() {
                  historyTab.classList.remove('text-primary', 'fw-bold');
                  this.removeEventListener('click', onceHandler);
                }, { once: true });
              }
            }
            
            // Update model badge if model info is available
            if (data.model) {
              const modelBadge = document.getElementById('model-badge');
              if (modelBadge) {
                updateModelBadge(data.model);
              }
            }
                        
            // Update compression stats
            updateCompressionStats();
            
            // Update save status
            lastSaveTime = new Date();
            saveStatusElement.textContent = `Last saved: ${lastSaveTime.toLocaleTimeString()}`;
          } else {
            addSystemMessage(`Error: ${data.error}`);
            saveStatusElement.textContent = 'Error saving';
          }
        } catch (error) {
          addSystemMessage(`Error sending message: ${error.message}`);
          saveStatusElement.textContent = 'Error saving';
        }
      }
      
      // Show/hide memory panel
      showMemoryButton.addEventListener('click', async () => {
        if (memoryPanel.style.display === 'none') {
          memoryPanel.style.display = 'block';
          showMemoryButton.innerHTML = '<i class="fas fa-brain me-1"></i> Hide Memory';
          
          // Fetch current memory state
          try {
            console.log("Fetching memory state for session:", activeSessionId);
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/memory/${activeSessionId}`));
            const data = await response.json();
            console.log("Received memory state:", data);
            
            // Make sure the Clothing tab is properly initialized
            const clothingTab = document.getElementById('clothing-tab');
            const clothingContent = document.getElementById('clothing-content');
            
            if (clothingTab && clothingContent) {
              console.log("Clothing tab elements found");
              
              // Make sure Bootstrap's tab system is properly set up
              const tabEl = new bootstrap.Tab(clothingTab);
            }
            
            // Make sure the Location tab is properly initialized
            const locationTab = document.getElementById('location-tab');
            const locationContent = document.getElementById('location-content');
            
            if (locationTab && locationContent) {
              console.log("Location tab elements found");
              
              // Make sure Bootstrap's tab system is properly set up
              const locationTabEl = new bootstrap.Tab(locationTab);
            }
            
            // Update the display with the memory state
            if (data.success) {
              updateMemoryDisplay(data.memoryState, data.characterProfile);
            } else {
              console.error('Error fetching memory:', data.error);
            }
          } catch (error) {
            console.error('Error fetching memory:', error);
          }
        } else {
          memoryPanel.style.display = 'none';
          showMemoryButton.innerHTML = '<i class="fas fa-brain me-1"></i> Memory';
        }
      });
            
      // Manually compress memory
      if (compressMemoryButton) {
        compressMemoryButton.addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          try {
            compressMemoryButton.disabled = true;
            compressMemoryButton.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Compressing...';
            
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/compression/compress'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              addSystemMessage(`Memory compression complete: ${data.beforeCount} → ${data.afterCount} items (${data.reductionPercent}% reduction)`);
              
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Update compression stats
              updateCompressionStats();
            } else {
              addSystemMessage(`Compression skipped: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            addSystemMessage(`Error compressing memory: ${error.message}`);
          } finally {
            compressMemoryButton.disabled = false;
            compressMemoryButton.innerHTML = '<i class="fas fa-compress-alt me-1"></i> Compress';
            compressNowButton.disabled = false;
            compressNowButton.innerHTML = '<i class="fas fa-sync-alt me-1"></i> Compress Now';
          }
        });
      }
      
      // Compression toggle change
      if (compressionToggle) {
        compressionToggle.addEventListener('change', async () => {
          if (!activeSessionId) return;
          
          try {
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/compression/toggle'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId,
                enabled: compressionToggle.checked
              })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
              console.error('Error toggling compression:', data.error);
              // Revert the toggle if there was an error
              compressionToggle.checked = !compressionToggle.checked;
            }
          } catch (error) {
            console.error('Error toggling compression:', error);
            // Revert the toggle if there was an error
            compressionToggle.checked = !compressionToggle.checked;
          }
        });
      }
      
      // Compress now button
      if (compressNowButton) {
        compressNowButton.addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          try {
            compressNowButton.disabled = true;
            compressNowButton.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Compressing...';
            
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl('/api/compression/compress'), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: activeSessionId,
                force: true
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              addSystemMessage(`Memory compressed: ${data.beforeCount} → ${data.afterCount} items (${data.reductionPercent}% reduction)`);
              
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Update compression stats
              updateCompressionStats();
            } else {
              addSystemMessage(`Compression skipped: ${data.error || 'Not enough memories to compress'}`);
            }
          } catch (error) {
            console.error('Error compressing memory:', error);
          } finally {
            compressNowButton.disabled = false;
            compressNowButton.innerHTML = '<i class="fas fa-sync-alt me-1"></i> Compress Now';
          }
        });
      }
      
      // Set character avatar based on character type
      function setCharacterAvatar(characterType) {
        if (!characterAvatar) return;
        
        // Remove all existing classes
        characterAvatar.className = 'message-avatar d-inline-block me-2';
        
        // Set background color based on character type
        switch (characterType) {
          case 'mentor':
            characterAvatar.style.backgroundColor = '#617c58';
            break;
          case 'therapist':
            characterAvatar.style.backgroundColor = '#81a4cd';
            break;
          case 'coach':
            characterAvatar.style.backgroundColor = '#b57e50';
            break;
          case 'creative':
            characterAvatar.style.backgroundColor = '#a45c94';
            break;
          case 'detective':
            characterAvatar.style.backgroundColor = '#4a6572';
            break;
          case 'custom':
            characterAvatar.style.backgroundColor = '#8e7cc3';
            break;
          default:
            characterAvatar.style.backgroundColor = 'var(--primary-color)';
        }
      }
      
      // Function to update compression stats
      function updateCompressionStats() {
        if (!activeSessionId) return;
        
        try {
          // If API is available, fetch stats from server
          if (typeof fetch !== 'undefined' && apiCallCountElement) {
            window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/compression/stats/${activeSessionId}`))
              .then(response => response.json())
              .then(stats => {
                if (stats) {
                  // Update toggle state
                  if (compressionToggle) {
                    compressionToggle.checked = stats.enabled;
                  }
                  
                  // Update stats display
                  if (apiCallCountElement) {
                    apiCallCountElement.textContent = stats.apiCallsSinceLastCompression;
                    
                    // Update progress bar
                    if (compressionProgressBar) {
                      const percent = Math.min(100, (stats.apiCallsSinceLastCompression / 10) * 100);
                      compressionProgressBar.style.width = `${percent}%`;
                    }
                  }
                  
                  if (compressionCountElement) {
                    compressionCountElement.textContent = stats.compressionCount || '0';
                  }
                  
                  // Format timestamp if available
                  if (lastCompressionTimeElement) {
                    if (stats.lastCompressionTime) {
                      const date = new Date(stats.lastCompressionTime);
                      lastCompressionTimeElement.textContent = date.toLocaleString();
                    } else {
                      lastCompressionTimeElement.textContent = 'Never';
                    }
                  }
                  
                  // Calculate compression ratio if available
                  if (lastCompressionRatioElement) {
                    if (stats.memoriesBeforeLastCompression && stats.memoriesAfterLastCompression) {
                      const ratio = ((stats.memoriesBeforeLastCompression - stats.memoriesAfterLastCompression) / stats.memoriesBeforeLastCompression * 100).toFixed(1);
                      lastCompressionRatioElement.textContent = `${stats.memoriesBeforeLastCompression} → ${stats.memoriesAfterLastCompression} (${ratio}%)`;
                    } else {
                      lastCompressionRatioElement.textContent = 'N/A';
                    }
                  }

                  // Update average compression ratio
                  const avgCompressionRatioElement = document.getElementById('avg-compression-ratio');
                  if (avgCompressionRatioElement && stats.averageCompressionReduction !== undefined) {
                    avgCompressionRatioElement.textContent = `${stats.averageCompressionReduction}%`;
                  }

                  // Update token usage statistics
                  if (stats.tokenUsage) {
                    const updateElement = (id, value) => {
                      const el = document.getElementById(id);
                      if (el) el.textContent = value.toLocaleString();
                    };

                    updateElement('total-tokens', stats.tokenUsage.totalTokens);
                    updateElement('total-input-tokens', stats.tokenUsage.totalInputTokens);
                    updateElement('total-output-tokens', stats.tokenUsage.totalOutputTokens);
                    updateElement('avg-tokens-per-msg', stats.tokenUsage.averageTokensPerMessage);
                    updateElement('peak-input-tokens', stats.tokenUsage.peakInputTokens);
                    updateElement('messages-processed', stats.tokenUsage.messagesProcessed);
                  }

                  // Update memory statistics
                  if (stats.memoryStats) {
                    const updateElement = (id, value) => {
                      const el = document.getElementById(id);
                      if (el) el.textContent = value.toLocaleString();
                    };

                    updateElement('memories-created', stats.memoryStats.totalMemoriesCreated);
                    updateElement('memories-compressed', stats.memoryStats.totalMemoriesCompressed);
                    updateElement('current-longterm', stats.memoryStats.currentLongTermMemories);
                  }

                  // Update current state
                  if (stats.currentState) {
                    const updateElement = (id, value) => {
                      const el = document.getElementById(id);
                      if (el) el.textContent = value.toLocaleString();
                    };

                    updateElement('current-shortterm', stats.currentState.shortTermMemoryCount);
                    updateElement('char-profile-bytes', stats.currentState.characterProfileBytes);
                    updateElement('user-profile-bytes', stats.currentState.userProfileBytes);
                    updateElement('deep-memory-length', stats.currentState.deepMemoryLength);
                  }

                  // Update topic distribution
                  const topicDistElement = document.getElementById('topic-distribution');
                  if (topicDistElement && stats.memoryStats && stats.memoryStats.topicDistribution) {
                    const topics = stats.memoryStats.topicDistribution;
                    const topicKeys = Object.keys(topics);

                    if (topicKeys.length === 0) {
                      topicDistElement.innerHTML = '<em class="text-muted">No data yet</em>';
                    } else {
                      // Sort topics by count (descending)
                      topicKeys.sort((a, b) => topics[b] - topics[a]);

                      // Create a list of topics
                      let html = '<div class="table-responsive"><table class="table table-sm table-striped">';
                      html += '<tbody>';

                      topicKeys.forEach(topic => {
                        const count = topics[topic];
                        const percentage = stats.memoryStats.totalMemoriesCreated > 0
                          ? ((count / stats.memoryStats.totalMemoriesCreated) * 100).toFixed(0)
                          : 0;

                        html += `<tr>
                          <td class="text-truncate" style="max-width: 150px;" title="${topic}">${topic}</td>
                          <td class="text-end">${count}</td>
                          <td class="text-end text-muted">${percentage}%</td>
                        </tr>`;
                      });

                      html += '</tbody></table></div>';
                      topicDistElement.innerHTML = html;
                    }
                  }

                  // Update compression history
                  const compressionHistoryElement = document.getElementById('compression-history');
                  if (compressionHistoryElement && stats.recentCompressions) {
                    const history = stats.recentCompressions;

                    if (history.length === 0) {
                      compressionHistoryElement.innerHTML = '<em class="text-muted">No compressions yet</em>';
                    } else {
                      let html = '<div class="list-group list-group-flush">';

                      // Show most recent compressions first (reverse order)
                      [...history].reverse().forEach((entry, index) => {
                        const date = new Date(entry.timestamp);
                        const timeStr = date.toLocaleString();
                        const reduction = entry.reductionPercent || 0;

                        html += `<div class="list-group-item px-0 py-2">
                          <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">${timeStr}</small>
                            <span class="badge bg-${reduction > 80 ? 'success' : reduction > 60 ? 'primary' : 'secondary'}">${reduction}%</span>
                          </div>
                          <small class="text-muted">
                            ${entry.beforeCounts.longTerm} → ${entry.afterCounts.longTerm} memories
                          </small>
                        </div>`;
                      });

                      html += '</div>';
                      compressionHistoryElement.innerHTML = html;
                    }
                  }
                }
              })
              .catch(error => console.error('Error fetching compression stats:', error));
          }
        } catch (error) {
          console.error('Error updating compression stats:', error);
        }
      }
      
      // Helper functions for adding messages
      function addUserMessage(message) {
        // Hide welcome placeholder when first message is sent
        if (welcomePlaceholder) {
          welcomePlaceholder.style.display = 'none';
        }
        
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message user-message';
        messageElement.textContent = message;
        
        // Add to container and append to messages
        messageContainer.appendChild(messageElement);
        messagesContainer.appendChild(messageContainer);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function addAssistantMessage(message, date = null, location = null, clothing = null) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';

        // Create avatar
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        avatar.style.backgroundColor = characterAvatar.style.backgroundColor;
        messageContainer.appendChild(avatar);

        // Create message bubble
        const messageBubble = document.createElement('div');
        messageBubble.className = 'message-bubble';

        // Create metadata container for date, location, and clothing badges
        const hasDate = date && date !== 'unknown' && date !== 'null';
        const hasLocation = location && location !== 'unknown' && location !== 'null';
        const hasClothing = clothing && clothing !== 'unknown' && clothing !== 'null' && clothing.trim() !== '';

        if (hasDate || hasLocation || hasClothing) {
          const metadataContainer = document.createElement('div');
          metadataContainer.className = 'message-metadata-container';

          // Add date badge if provided
          if (hasDate) {
            const dateBadge = document.createElement('span');
            dateBadge.className = 'message-date-badge';
            dateBadge.textContent = date;
            metadataContainer.appendChild(dateBadge);
          }

          // Add location badge if provided
          if (hasLocation) {
            const locationBadge = document.createElement('span');
            locationBadge.className = 'message-location-badge';
            locationBadge.innerHTML = `📍 ${location}`;
            metadataContainer.appendChild(locationBadge);
          }

          // Add clothing badge if provided
          if (hasClothing) {
            const clothingBadge = document.createElement('span');
            clothingBadge.className = 'message-clothing-badge';
            clothingBadge.innerHTML = `👗 ${clothing}`;
            metadataContainer.appendChild(clothingBadge);
          }

          messageBubble.appendChild(metadataContainer);
        }

        const messageElement = document.createElement('div');
        messageElement.className = 'message assistant-message';

        // Parse markdown content
        try {
          // Render the markdown content
          messageElement.innerHTML = marked.parse(message);

          // Find all code blocks and apply syntax highlighting
          messageElement.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
          });
        } catch (error) {
          // Fallback to plain text if markdown parsing fails
          console.error('Error parsing markdown:', error);
          messageElement.textContent = message;
        }

        messageBubble.appendChild(messageElement);
        messageContainer.appendChild(messageBubble);
        messagesContainer.appendChild(messageContainer);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function addSystemMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = 'system-message';
        messageElement.textContent = message;
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Update header badges with current location and clothing
      function updateHeaderBadges(location = null, clothing = null) {
        // Update location badge
        const hasLocation = location && location !== 'unknown' && location !== 'null' && location.trim() !== '';
        if (hasLocation && headerLocationBadge) {
          headerLocationBadge.innerHTML = `📍 ${location}`;
          headerLocationBadge.style.display = 'inline-block';
        } else if (headerLocationBadge) {
          headerLocationBadge.style.display = 'none';
        }

        // Update clothing badge (only show character clothing in header)
        let charClothing = '';
        if (clothing && typeof clothing === 'object' && clothing.char) {
          charClothing = clothing.char;
        } else if (typeof clothing === 'string') {
          charClothing = clothing;
        }

        const hasClothing = charClothing && charClothing !== 'unknown' && charClothing !== 'null' && charClothing.trim() !== '';
        if (hasClothing && headerClothingBadge) {
          headerClothingBadge.innerHTML = `👗 ${charClothing}`;
          headerClothingBadge.style.display = 'inline-block';
        } else if (headerClothingBadge) {
          headerClothingBadge.style.display = 'none';
        }
      }

      // Handle deep memory save
      if (document.getElementById('save-deep-memory')) {
        document.getElementById('save-deep-memory').addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          const deepMemoryContent = document.getElementById('update-deep-memory').value.trim();
          
          try {
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/deep-memory/${activeSessionId}`), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                content: deepMemoryContent
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              // Update memory display if visible
              if (memoryPanel.style.display !== 'none') {
                updateMemoryDisplay(data.memoryState);
              }
              
              addSystemMessage('Deep memory updated successfully');
            } else {
              addSystemMessage(`Error updating deep memory: ${data.error}`);
            }
          } catch (error) {
            console.error('Error updating deep memory:', error);
            addSystemMessage(`Error updating deep memory: ${error.message}`);
          }
        });
      }
      
      // Handle clothing information save
      if (document.getElementById('save-clothing')) {
        document.getElementById('save-clothing').addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          const characterClothing = document.getElementById('update-character-clothing').value.trim();
          const userClothing = document.getElementById('update-user-clothing').value.trim();
          
          try {
            // Use the dedicated API endpoint for updating clothing
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/clothing/${activeSessionId}`), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                characterClothing,
                userClothing
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Add system message
              addSystemMessage('Clothing information updated successfully');
              
              // Update save status
              lastSaveTime = new Date();
              saveStatusElement.textContent = `Last saved: ${lastSaveTime.toLocaleTimeString()}`;
            } else {
              addSystemMessage(`Error updating clothing information: ${data.error}`);
            }
          } catch (error) {
            console.error('Error updating clothing information:', error);
            addSystemMessage(`Error updating clothing information: ${error.message}`);
          }
        });
      }
      
      // Handle location information save
      if (document.getElementById('save-location')) {
        document.getElementById('save-location').addEventListener('click', async () => {
          if (!activeSessionId) return;
          
          const characterLocation = document.getElementById('update-character-location').value.trim();
          
          try {
            // Use the dedicated API endpoint for updating location
            const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/location/${activeSessionId}`), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                characterLocation
              })
            });
            
            const data = await response.json();
            
            if (response.ok) {
              // Update memory display
              if (memoryPanel.style.display !== 'none' && data.memoryState) {
                updateMemoryDisplay(data.memoryState);
              }
              
              // Add system message
              addSystemMessage('Location information updated successfully');
              
              // Update save status
              lastSaveTime = new Date();
              saveStatusElement.textContent = `Last saved: ${lastSaveTime.toLocaleTimeString()}`;
            } else {
              addSystemMessage(`Error updating location information: ${data.error}`);
            }
          } catch (error) {
            console.error('Error updating location information:', error);
            addSystemMessage(`Error updating location information: ${error.message}`);
          }
        });
      }
      
      // Function to fetch and display relationship history
      async function fetchRelationshipHistory() {
        if (!activeSessionId) return;
        
        try {
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/history/${activeSessionId}`));
          const data = await response.json();
          
          if (response.ok && data.success) {
            updateHistoryDisplay(data.history, data.characterName);
          } else {
            console.error('Error fetching history:', data.error);
          }
        } catch (error) {
          console.error('Error fetching relationship history:', error);
        }
      }
      
      // Function to update the history display with relationship data
      function updateHistoryDisplay(historyEntries, characterName) {
        const historyList = document.getElementById('relationship-history');
        if (!historyList) return;
        
        // Clear existing entries
        historyList.innerHTML = '';
        
        if (!historyEntries || historyEntries.length === 0) {
          // Show empty state
          const emptyItem = document.createElement('li');
          emptyItem.className = 'list-group-item text-center text-muted';
          emptyItem.textContent = 'No relationship history entries yet';
          historyList.appendChild(emptyItem);
          return;
        }
        
        // Sort history by timestamp, newest first
        const sortedHistory = [...historyEntries].sort((a, b) => {
          return new Date(b.timestamp || 0) - new Date(a.timestamp || 0);
        });
        
        // Check if edit mode is enabled
        const editMode = document.getElementById('history-edit-mode').checked;
        
        // Create list items for each history entry
        sortedHistory.forEach(entry => {
          const item = document.createElement('li');
          item.className = 'list-group-item';
          
          // Store entry ID or timestamp for deletion reference
          if (entry.id) {
            item.dataset.entryId = entry.id;
          } else if (entry.timestamp) {
            item.dataset.timestamp = entry.timestamp;
          }
          
          // Format timestamp
          const timestamp = entry.timestamp ? new Date(entry.timestamp).toLocaleString() : 'Unknown date';
          
          // Create HTML content based on edit mode status
          if (editMode) {
            item.innerHTML = `
              <div class="d-flex justify-content-between align-items-center">
                <div class="form-check">
                  <input class="form-check-input history-entry-checkbox" type="checkbox" value="">
                  <label class="form-check-label">
                    <span class="badge bg-primary me-2">${timestamp}</span>
                    <strong>${entry.change || entry.text}</strong>
                  </label>
                </div>
              </div>
            `;
          } else {
            item.innerHTML = `
              <div class="d-flex justify-content-between align-items-top">
                <span class="badge bg-primary">${timestamp}</span>
              </div>
              <div class="mt-2">
                <strong>${entry.change || entry.text}</strong>
              </div>
            `;
          }
          
          historyList.appendChild(item);
        });
      }
      
      // Function to delete selected history entries
      async function deleteSelectedHistoryEntries() {
        if (!activeSessionId) return;
        
        // Get all checked checkboxes
        const selectedCheckboxes = document.querySelectorAll('.history-entry-checkbox:checked');
        if (selectedCheckboxes.length === 0) return;
        
        // Confirm deletion
        if (!confirm(`Delete ${selectedCheckboxes.length} selected history entries?`)) {
          return;
        }
        
        // Collect entry IDs or timestamps for deletion
        const entriesToDelete = [];
        selectedCheckboxes.forEach(checkbox => {
          const listItem = checkbox.closest('li');
          const entryId = listItem.dataset.entryId;
          const timestamp = listItem.dataset.timestamp;
          
          if (entryId) {
            entriesToDelete.push({ id: entryId });
          } else if (timestamp) {
            entriesToDelete.push({ timestamp });
          }
        });
        
        if (entriesToDelete.length === 0) return;
        
        try {
          // Call the API to delete the entries
          const response = await window.ServerConfig.fetchWithCredentials(window.ServerConfig.buildApiUrl(`/api/history/${activeSessionId}`), {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              entries: entriesToDelete
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            // Refresh the history display
            fetchRelationshipHistory();
            
            // Add success message
            addSystemMessage(`Deleted ${entriesToDelete.length} history entries`);
          } else {
            console.error('Error deleting history entries:', data.error);
            addSystemMessage(`Error deleting history entries: ${data.error}`);
          }
        } catch (error) {
          console.error('Error deleting history entries:', error);
          addSystemMessage(`Error deleting history entries: ${error.message}`);
        }
      }
      
      // Add event handler for the refresh history button
      const refreshHistoryButton = document.getElementById('refresh-history');
      if (refreshHistoryButton) {
        refreshHistoryButton.addEventListener('click', fetchRelationshipHistory);
      }
      
      // Handle edit mode toggle
      const historyEditModeToggle = document.getElementById('history-edit-mode');
      const deleteSelectedHistoryButton = document.getElementById('delete-selected-history');
      
      if (historyEditModeToggle) {
        historyEditModeToggle.addEventListener('change', () => {
          // Toggle the visibility of the delete button
          if (deleteSelectedHistoryButton) {
            deleteSelectedHistoryButton.style.display = historyEditModeToggle.checked ? 'block' : 'none';
          }
          
          // Refresh the history display to show/hide checkboxes
          fetchRelationshipHistory();
        });
      }
      
      // Add event handler for the delete button
      if (deleteSelectedHistoryButton) {
        deleteSelectedHistoryButton.addEventListener('click', deleteSelectedHistoryEntries);
      }
      
      // Hook into the tab system to load history when the tab is shown
      const historyTab = document.getElementById('history-tab');
      if (historyTab) {
        historyTab.addEventListener('shown.bs.tab', fetchRelationshipHistory);
      }

      function updateMemoryDisplay(memoryState, characterProfile) {
        if (!memoryState) return;
        
        // Clear current memory display
        shortTermMemoryList.innerHTML = '';
        longTermMemoryList.innerHTML = '';
        
        // Update deep memory display
        const deepMemoryDisplay = document.getElementById('deep-memory-display');
        const updateDeepMemoryInput = document.getElementById('update-deep-memory');
        
        if (deepMemoryDisplay && memoryState.deepMemory) {
          deepMemoryDisplay.innerHTML = `<div class="card p-3 bg-light"><h5>Current Deep Memory:</h5><p>${memoryState.deepMemory.replace(/\n/g, '<br>')}</p></div>`;
        }
        
        if (updateDeepMemoryInput && memoryState.deepMemory) {
          updateDeepMemoryInput.value = memoryState.deepMemory;
        }

        // Update character profile display
        const characterProfileDisplay = document.querySelector('#character-profile-display pre');
        if (characterProfileDisplay) {
          if (characterProfile) {
            characterProfileDisplay.textContent = characterProfile;
          } else {
            characterProfileDisplay.textContent = "Kein Charakterprofil verfügbar";
          }
        }
        
        // Update clothing information if available
        console.log("Memory state for clothing:", memoryState.clothing);
        
        const characterClothingElement = document.getElementById('character-clothing');
        const userClothingElement = document.getElementById('user-clothing');
        const updateCharacterClothingInput = document.getElementById('update-character-clothing');
        const updateUserClothingInput = document.getElementById('update-user-clothing');
        
        // Also check for history data and update if available
        if (memoryState.history && Array.isArray(memoryState.history)) {
          // Update history display if that tab is visible
          const historyTab = document.getElementById('history-tab');
          if (historyTab && historyTab.classList.contains('active')) {
            updateHistoryDisplay(memoryState.history, characterNameElement.textContent);
          }
        }
        
        if (memoryState.clothing) {
          // Check for possible clothing structures
          let charClothing = "";
          let userClothing = "";
          
          if (memoryState.clothing.clothing) {
            // Structure: {clothing: {char: "...", user: "..."}}
            charClothing = memoryState.clothing.clothing.char || "";
            userClothing = memoryState.clothing.clothing.user || "";
          } else if (typeof memoryState.clothing === 'object') {
            // Try to find char/user properties directly
            charClothing = memoryState.clothing.char || "";
            userClothing = memoryState.clothing.user || "";
          }
          
          if (characterClothingElement) {
            characterClothingElement.textContent = charClothing || "No information available";
          }
          
          if (userClothingElement) {
            userClothingElement.textContent = userClothing || "No information available";
          }
          
          if (updateCharacterClothingInput) {
            updateCharacterClothingInput.value = charClothing;
          }
          
          if (updateUserClothingInput) {
            updateUserClothingInput.value = userClothing;
          }
        }
        
        // Update location information if available
        console.log("Memory state for location:", memoryState.location);
        
        const characterLocationElement = document.getElementById('character-location');
        const updateCharacterLocationInput = document.getElementById('update-character-location');
        
        if (memoryState.location) {
          if (characterLocationElement) {
            characterLocationElement.textContent = memoryState.location || "No information available";
          }
          
          if (updateCharacterLocationInput) {
            updateCharacterLocationInput.value = memoryState.location || "";
          }
        }
        
        // Add short-term memory items
        if (memoryState.shortTerm && Array.isArray(memoryState.shortTerm)) {
          memoryState.shortTerm.forEach(item => {
            const li = createMemoryItem(item, 'short-term');
            shortTermMemoryList.appendChild(li);
          });
        }
        
        // Add long-term memory items - group by topic structure
        if (memoryState.longTerm && Array.isArray(memoryState.longTerm)) {
          // Check if we have topic groups in the memories
          const hasTopicGroups = memoryState.longTerm.some(memory => 
            memory.topicGroup || memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/)
          );
          
          if (hasTopicGroups) {
            // Organize memories by topic groups
            const groupedMemories = {};
            
            // Process and group memories
            memoryState.longTerm.forEach(memory => {
              let group = 'Uncategorized';
              
              // Extract topic group from property or content
              if (memory.topicGroup) {
                group = memory.topicGroup;
              } else {
                // Try to extract from content with format [GROUP:subgroup]
                const topicMatch = memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/);
                if (topicMatch) {
                  group = topicMatch[1];
                } else {
                  // Check for old category format
                  const categoryMatch = memory.content.match(/^\[([A-Z_]+)\]/);
                  if (categoryMatch) {
                    group = categoryMatch[1];
                  }
                }
              }
              
              // Initialize group if it doesn't exist
              if (!groupedMemories[group]) {
                groupedMemories[group] = [];
              }
              
              // Add to group
              groupedMemories[group].push(memory);
            });
            
            // Create topic group headers and add memories under each
            Object.entries(groupedMemories).forEach(([group, memories]) => {
              // Sort memories by importance within each group
              memories.sort((a, b) => (b.importance || 0.5) - (a.importance || 0.5));
              
              // Create group header
              const groupHeader = document.createElement('div');
              groupHeader.className = 'memory-group-header';
              let headerColor = 'secondary';
              
              // Different colors for different topic groups
              if (group === 'USER_IDENTITY') headerColor = 'info';
              else if (group === 'CHARACTER_IDENTITY') headerColor = 'success';
              else if (group === 'RELATIONSHIP') headerColor = 'danger';
              else if (group === 'CONVERSATION_THREADS') headerColor = 'warning';
              
              // Format group name for display
              const displayName = group.replace(/_/g, ' ');
              
              groupHeader.innerHTML = `
                <span class="badge bg-${headerColor} me-2">${displayName}</span>
                <span class="badge bg-light text-dark">${memories.length} items</span>
              `;
              longTermMemoryList.appendChild(groupHeader);
              
              // Add memories in each group
              memories.forEach(memory => {
                const li = createMemoryItem(memory, 'long-term');
                longTermMemoryList.appendChild(li);
              });
              
              // Add separator between groups
              const separator = document.createElement('hr');
              separator.className = 'my-2';
              longTermMemoryList.appendChild(separator);
            });
          } else {
            // Traditional display without grouping
            memoryState.longTerm.forEach(item => {
              const li = createMemoryItem(item, 'long-term');
              longTermMemoryList.appendChild(li);
            });
          }
        }
      }
      
      function createMemoryItem(memory, itemType) {
        const li = document.createElement('li');
        li.className = 'memory-item position-relative';
        
        // Add compressed indicator
        if (memory.compressed) {
          li.classList.add('compressed');
        }
        
        // Add importance-based styling if available
        if (memory.importance !== undefined) {
          // Add importance class based on score
          const importanceScore = memory.importance;
          if (importanceScore >= 0.8) {
            li.classList.add('high-importance');
          } else if (importanceScore >= 0.5) {
            li.classList.add('medium-importance');
          } else {
            li.classList.add('low-importance');
          }
          
          // Set a subtle border color based on importance
          const colorIntensity = Math.floor(memory.importance * 100);
          li.style.borderLeftColor = `rgba(106, 90, 205, ${memory.importance})`;
        }
        
        let contentHTML = '';
        
        if (itemType === 'short-term') {
          // For short-term memory
          contentHTML = `<strong>${memory.role || 'user'}:</strong> ${memory.content.substring(0, 50)}${memory.content.length > 50 ? '...' : ''}`;
        } else {
          // For long-term memory
          let displayContent = memory.content.substring(0, 100) + (memory.content.length > 100 ? '...' : '');
          
          // Extract topic group if available (new format)
          const topicMatch = memory.content.match(/^\[([\w_]+)(?::[^\]]+)?\]/);
          
          // Add badges for topic group and importance
          let badges = '';
          
          // Add compression badge
          if (memory.compressed) {
            badges += `<span class="badge bg-primary me-1">Compressed</span>`;
          }
          
          // Add topic badge if available
          if (topicMatch) {
            const topicGroup = topicMatch[1];
            let badgeColor = 'bg-secondary';
            
            // Different colors for different topic groups
            if (topicGroup === 'USER_IDENTITY') badgeColor = 'bg-info';
            else if (topicGroup === 'CHARACTER_IDENTITY') badgeColor = 'bg-success';
            else if (topicGroup === 'RELATIONSHIP') badgeColor = 'bg-danger';
            else if (topicGroup === 'CONVERSATION_THREADS') badgeColor = 'bg-warning text-dark';
            
            badges += `<span class="badge ${badgeColor} me-1">${topicGroup.replace('_', ' ')}</span>`;
          } else {
            // Look for old category format [CATEGORY]
            const categoryMatch = memory.content.match(/^\[([A-Z_]+)\]/);
            if (categoryMatch) {
              badges += `<span class="badge bg-secondary me-1">${categoryMatch[1]}</span>`;
            }
          }
          
          // Add importance badge if available
          if (memory.importance !== undefined) {
            const importancePercent = Math.round(memory.importance * 100);
            badges += `<span class="badge bg-info me-1" title="Importance score">${importancePercent}%</span>`;
          }
          
          // Add access count badge if memory has been accessed
          if (memory.accessCount && memory.accessCount > 0) {
            badges += `<span class="badge bg-success me-1" title="Number of times this memory was accessed">Used: ${memory.accessCount}×</span>`;
          }
          
          contentHTML = badges ? `<div class="mb-1">${badges}</div>` : '';
          contentHTML += displayContent;
        }
        
        // Create the tooltip with full content
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip-text';
        
        if (itemType === 'short-term') {
          tooltip.innerHTML = `<strong>${memory.role || 'user'}:</strong><br>${memory.content}`;
        } else {
          // Enhanced tooltip for long-term memory
          tooltip.innerHTML = `<div class="mb-2">${memory.content}</div>`;
          
          // Add metadata in the tooltip
          let metadataHTML = '<div class="memory-metadata">';
          
          // Add timestamp
          if (memory.timestamp) {
            const date = new Date(memory.timestamp);
            metadataHTML += `<div>Stored: ${date.toLocaleString()}</div>`;
          }
          
          // Add access information
          if (memory.accessCount !== undefined) {
            metadataHTML += `<div>Access count: ${memory.accessCount}</div>`;
            
            if (memory.lastAccessed) {
              const accessDate = new Date(memory.lastAccessed);
              metadataHTML += `<div>Last accessed: ${accessDate.toLocaleString()}</div>`;
            }
          }
          
          // Add importance score
          if (memory.importance !== undefined) {
            const importancePercent = Math.round(memory.importance * 100);
            metadataHTML += `<div>Importance: ${importancePercent}%</div>`;
          }
          
          // Add topic group and subtopic
          if (memory.topicGroup) {
            metadataHTML += `<div>Topic group: ${memory.topicGroup}</div>`;
            
            if (memory.subtopic) {
              metadataHTML += `<div>Subtopic: ${memory.subtopic}</div>`;
            }
          }
          
          // Close metadata div and add to tooltip
          metadataHTML += '</div>';
          tooltip.innerHTML += metadataHTML;
        }
        
        // Create a content wrapper div instead of setting innerHTML directly
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'memory-content';
        contentWrapper.innerHTML = contentHTML;
        
        // Append both content and tooltip to the li element
        li.appendChild(contentWrapper);
        li.appendChild(tooltip);
        
        // Add a manual hover event for better tooltip control
        li.addEventListener('mouseenter', (e) => {
          // Get mouse position
          const rect = li.getBoundingClientRect();
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          
          // Position tooltip
          tooltip.style.top = (rect.top + scrollTop - 10) + 'px';
          tooltip.style.left = (rect.left + rect.width + 20) + 'px';
          
          // If tooltip would go off right edge, show it on the left side instead
          if (rect.left + rect.width + 20 + 350 > window.innerWidth) {
            tooltip.style.left = (rect.left - 370) + 'px';
          }
          
          // Make tooltip visible
          tooltip.style.visibility = 'visible';
          tooltip.style.opacity = '1';
          tooltip.style.transform = 'translateY(0)';
          
          // Prevent tooltip from being too low on the screen
          const tooltipRect = tooltip.getBoundingClientRect();
          if (tooltipRect.bottom > window.innerHeight) {
            tooltip.style.top = (window.innerHeight - tooltipRect.height + scrollTop - 20) + 'px';
          }
        });
        
        li.addEventListener('mouseleave', () => {
          tooltip.style.visibility = 'hidden';
          tooltip.style.opacity = '0';
          tooltip.style.transform = 'translateY(10px)';
        });
        
        return li;
      }
      
      // Set up periodic updates for compression stats
      if (activeSessionId) {
        setInterval(updateCompressionStats, 10000); // Every 10 seconds
      }
      
      // Set up language selector event listeners
      const languageSelect = document.getElementById('language-select');
      if (languageSelect) {
        // Initialize with current language
        currentLanguage = languageSelect.value || 'english';
        
        // Add event listener for language changes
        languageSelect.addEventListener('change', (e) => {
          currentLanguage = e.target.value;
          updateUILanguage(currentLanguage);
        });
      }
      
      // Apply translations on page load
      updateUILanguage(currentLanguage);
      
      // Also handle the load session language selector
      const loadLanguageSelect = document.getElementById('load-language-select');
      if (loadLanguageSelect) {
        loadLanguageSelect.addEventListener('change', (e) => {
          currentLanguage = e.target.value;
          updateUILanguage(currentLanguage);
        });
      }

      // Server Configuration Modal functionality
      const serverConfigModal = document.getElementById('serverConfigModal');
      const serverUrlInput = document.getElementById('serverUrl');
      const currentServerUrlSpan = document.getElementById('currentServerUrl');
      const testConnectionBtn = document.getElementById('testConnectionBtn');
      const connectionStatus = document.getElementById('connectionStatus');
      const saveServerConfigBtn = document.getElementById('saveServerConfig');

      // Update modal when shown
      serverConfigModal.addEventListener('show.bs.modal', function() {
        serverUrlInput.value = window.ServerConfig.serverUrl;
        currentServerUrlSpan.textContent = window.ServerConfig.serverUrl;
        connectionStatus.innerHTML = '';
      });

      // Test connection functionality
      testConnectionBtn.addEventListener('click', async function() {
        const testUrl = serverUrlInput.value.trim();
        if (!testUrl) {
          connectionStatus.innerHTML = '<span class="text-warning"><i class="fas fa-exclamation-triangle"></i> Please enter a server URL</span>';
          return;
        }

        testConnectionBtn.disabled = true;
        connectionStatus.innerHTML = '<span class="text-info"><i class="fas fa-spinner fa-spin"></i> Testing connection...</span>';

        try {
          // Test connection using health check endpoint (no auth required)
          const testApiUrl = testUrl.replace(/\/$/, '') + '/api/health';
          const response = await fetch(testApiUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json'
            },
            credentials: 'omit' // Don't send credentials for health check
          });

          if (response.ok) {
            const healthData = await response.json();
            connectionStatus.innerHTML = `<span class="text-success"><i class="fas fa-check-circle"></i> Connected to ${healthData.message || 'Persona server'}!</span>`;
          } else {
            connectionStatus.innerHTML = `<span class="text-danger"><i class="fas fa-times-circle"></i> Connection failed (${response.status})</span>`;
          }
        } catch (error) {
          connectionStatus.innerHTML = `<span class="text-danger"><i class="fas fa-times-circle"></i> Connection failed: ${error.message}</span>`;
        } finally {
          testConnectionBtn.disabled = false;
        }
      });

      // Save configuration
      saveServerConfigBtn.addEventListener('click', function() {
        const newUrl = serverUrlInput.value.trim();
        if (!newUrl) {
          alert('Please enter a valid server URL');
          return;
        }

        window.ServerConfig.setServerUrl(newUrl);
        
        // Update placeholder images with new server URL
        window.ServerConfig.updatePlaceholderImages();
        
        // Hide modal
        const modal = bootstrap.Modal.getInstance(serverConfigModal);
        modal.hide();
        
        // Show success message
        alert('Server configuration saved! All API calls will now use the new server.');
        
        // Don't reload page anymore - changes are applied dynamically
      });
      
      // Initialize character loading on page load
      loadAvailableCharacters();

      // ===== Session Manager Functions =====
      let allSessions = [];
      let filteredSessions = [];

      // Load sessions when modal is opened
      document.getElementById('sessionManagerModal').addEventListener('show.bs.modal', async function() {
        await loadSessions();
      });

      // Search functionality
      document.getElementById('session-search').addEventListener('input', function(e) {
        const searchTerm = e.target.value.toLowerCase();
        filterSessions(searchTerm);
      });

      async function loadSessions() {
        const loadingEl = document.getElementById('sessions-loading');
        const emptyEl = document.getElementById('sessions-empty');
        const listEl = document.getElementById('sessions-list');

        // Show loading state
        loadingEl.style.display = 'block';
        emptyEl.style.display = 'none';
        listEl.innerHTML = '';

        try {
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl('/api/sessions')
          );

          if (!response.ok) {
            throw new Error(`Failed to load sessions: ${response.statusText}`);
          }

          allSessions = await response.json();
          filteredSessions = [...allSessions];

          loadingEl.style.display = 'none';

          if (allSessions.length === 0) {
            emptyEl.style.display = 'block';
          } else {
            renderSessions(filteredSessions);
          }
        } catch (error) {
          console.error('Error loading sessions:', error);
          loadingEl.style.display = 'none';
          emptyEl.style.display = 'block';
          listEl.innerHTML = `<div class="col-12"><div class="alert alert-danger">Error loading sessions: ${error.message}</div></div>`;
        }
      }

      function filterSessions(searchTerm) {
        if (!searchTerm) {
          filteredSessions = [...allSessions];
        } else {
          filteredSessions = allSessions.filter(session => {
            const characterMatch = session.characterName && session.characterName.toLowerCase().includes(searchTerm);
            const userMatch = session.userName && session.userName.toLowerCase().includes(searchTerm);
            return characterMatch || userMatch;
          });
        }

        const emptyEl = document.getElementById('sessions-empty');
        const listEl = document.getElementById('sessions-list');

        if (filteredSessions.length === 0) {
          emptyEl.style.display = 'block';
          listEl.innerHTML = '';
        } else {
          emptyEl.style.display = 'none';
          renderSessions(filteredSessions);
        }
      }

      function renderSessions(sessions) {
        const listEl = document.getElementById('sessions-list');
        listEl.innerHTML = '';

        sessions.forEach(session => {
          const card = createSessionCard(session);
          listEl.appendChild(card);
        });
      }

      function createSessionCard(session) {
        const col = document.createElement('div');
        col.className = 'col-12';

        const firstDate = new Date(session.firstMessageDate).toLocaleDateString();
        const lastDate = new Date(session.lastMessageDate).toLocaleDateString();
        const userName = session.userName || '<span class="text-muted">Unknown</span>';

        col.innerHTML = `
          <div class="card" style="transition: transform 0.2s;">
            <div class="card-body">
              <div class="row">
                <div class="col-md-8">
                  <h6 class="card-title mb-2">
                    <i class="fas fa-user-circle me-1" style="color: var(--primary-color);"></i>
                    <strong>Character:</strong> ${escapeHtml(session.characterName)}
                  </h6>
                  <p class="card-text small mb-1">
                    <i class="fas fa-user me-1" style="color: var(--dark-accent);"></i>
                    <strong>User:</strong> ${userName}
                  </p>
                  <p class="card-text small mb-1">
                    <i class="fas fa-comments me-1" style="color: var(--dark-accent);"></i>
                    <strong>Messages:</strong> ${session.messageCount}
                  </p>
                  <p class="card-text small text-muted mb-0">
                    <i class="fas fa-calendar me-1"></i>
                    <strong>First:</strong> ${firstDate} | <strong>Last:</strong> ${lastDate}
                  </p>
                </div>
                <div class="col-md-4 d-flex flex-column justify-content-center align-items-end">
                  <button class="btn btn-sm btn-primary mb-2 w-100 resume-btn" data-session-id="${session.sessionId}">
                    <i class="fas fa-play me-1"></i> Resume
                  </button>
                  <button class="btn btn-sm btn-outline-secondary mb-2 w-100 view-json-btn" data-session-id="${session.sessionId}">
                    <i class="fas fa-file-code me-1"></i> View JSON
                  </button>
                  <button class="btn btn-sm btn-outline-danger w-100 delete-btn" data-session-id="${session.sessionId}" data-character-name="${escapeHtml(session.characterName)}">
                    <i class="fas fa-trash me-1"></i> Delete
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;

        // Add event listeners
        const resumeBtn = col.querySelector('.resume-btn');
        const viewJsonBtn = col.querySelector('.view-json-btn');
        const deleteBtn = col.querySelector('.delete-btn');

        resumeBtn.addEventListener('click', () => {
          resumeSessionHandler(session.sessionId);
        });

        viewJsonBtn.addEventListener('click', () => {
          viewSessionJson(session.sessionId);
        });

        deleteBtn.addEventListener('click', () => {
          deleteSessionConfirmHandler(session.sessionId, session.characterName);
        });

        return col;
      }

      // Resume session handler
      async function resumeSessionHandler(sessionId) {
        try {
          // Load the session (using same approach as existing Load Session)
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl('/api/session'),
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: sessionId,
                apiKey: null, // Will use stored API key
                language: 'english' // Default language
              })
            }
          );

          const data = await response.json();

          if (!response.ok) {
            alert(`Error: ${data.error || 'Failed to load session'}`);
            return;
          }

          // Update UI - matching the existing Load Session behavior
          activeSessionId = data.sessionId;
          console.log('Resume: Set activeSessionId to:', activeSessionId);

          if (characterNameElement) characterNameElement.textContent = data.characterName;
          if (sessionInfoElement) sessionInfoElement.textContent = `Active session: ${data.characterName}`;
          if (saveStatusElement) saveStatusElement.textContent = 'Auto-saving enabled';
          if (saveSessionButton) saveSessionButton.disabled = false;

          // Set character avatar background color
          if (typeof setCharacterAvatar === 'function') {
            setCharacterAvatar(data.characterType);
          }

          // Hide setup and show chat
          if (setupContainer) setupContainer.style.display = 'none';
          if (sessionLoader) sessionLoader.style.display = 'none';
          if (chatContainer) chatContainer.style.display = 'flex';
          if (sessionInfoCard) sessionInfoCard.style.display = 'flex';

          // Hide welcome placeholder
          if (welcomePlaceholder) welcomePlaceholder.style.display = 'none';

          // Clear messages and add system message
          if (messagesContainer) {
            messagesContainer.innerHTML = '';
            addSystemMessage(`Session loaded! Continue your conversation with ${data.characterName}.`);
          }

          // Update model badge and currentModel variable if available
          const modelBadge = document.getElementById('model-badge');
          if (data.model) {
            currentModel = data.model;
            updateModelBadge(data.model);
          }

          // Update memory display if visible
          if (memoryPanel.style.display !== 'none') {
            updateMemoryDisplay(data.memoryState);
          }

          // Update header badges with current location and clothing
          if (data.memoryState) {
            updateHeaderBadges(data.memoryState.location, data.memoryState.clothing);
          }

          // Update compression toggle
          if (compressionToggle && data.memoryState && data.memoryState.compressionEnabled !== undefined) {
            compressionToggle.checked = data.memoryState.compressionEnabled;
          }

          // Update compression stats
          updateCompressionStats();

          // Close the modal AFTER everything is set up
          const modal = bootstrap.Modal.getInstance(document.getElementById('sessionManagerModal'));
          if (modal) modal.hide();
        } catch (error) {
          console.error('Error resuming session:', error);
          alert(`Error resuming session: ${error.message}`);
        }
      }

      function deleteSessionConfirmHandler(sessionId, characterName) {
        if (confirm(`Are you sure you want to delete the chat with ${characterName}?\n\nThis action cannot be undone.`)) {
          deleteSessionHandler(sessionId);
        }
      }

      async function deleteSessionHandler(sessionId) {
        try {
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl(`/api/session/${sessionId}`),
            {
              method: 'DELETE'
            }
          );

          if (!response.ok) {
            throw new Error(`Failed to delete session: ${response.statusText}`);
          }

          // Reload sessions list
          await loadSessions();

          // If this was the active session, reset the UI
          if (activeSessionId === sessionId) {
            activeSessionId = null;
            if (setupContainer) setupContainer.style.display = 'block';
            if (chatContainer) chatContainer.style.display = 'none';
            if (sessionInfoCard) sessionInfoCard.style.display = 'none';
            const chatMessagesEl = document.getElementById('messages');
            if (chatMessagesEl) chatMessagesEl.innerHTML = '';
          }
        } catch (error) {
          console.error('Error deleting session:', error);
          alert(`Error deleting session: ${error.message}`);
        }
      }

      // Convert session data to readable Markdown format
      function convertToReadable(sessionData) {
        const charProfile = sessionData.characterProfile || '';
        const userProfile = sessionData.userProfile || '';

        // Extract character name
        let charName = 'Unknown';
        const charNameMatch = charProfile.match(/NAME:\s*(.+?)(?:\n|$)/i);
        if (charNameMatch) charName = charNameMatch[1].trim();

        // Extract user name - be careful with empty or invalid names
        let userName = 'User';
        if (userProfile && userProfile.trim()) {
          // Match NAME: at the start of a line, followed by non-empty content
          const userNameMatch = userProfile.match(/^NAME:\s*(.+?)$/im);
          if (userNameMatch) {
            const extractedName = userNameMatch[1].trim();
            // Only use extracted name if it's valid (not empty, not "ID:", not just special chars)
            if (extractedName &&
                extractedName.length > 0 &&
                !extractedName.startsWith('ID:') &&
                !extractedName.match(/^[\/\*\s]+$/)) {
              userName = extractedName;
            }
          }
        }

        const timestamp = sessionData.timestamp || '';
        const date = sessionData.date || '';
        const sessionId = sessionData.sessionId || '';

        let output = `# ${charName} – Session ${date}\n\n`;
        output += `**Session ID:** \`${sessionId}\`  \n`;
        output += `**Started:** ${timestamp}\n\n`;
        output += '='.repeat(80) + '\n\n';

        // Process messages
        const messages = sessionData.messages || [];
        messages.forEach((msg, i) => {
          const role = msg.role || '';
          let content = msg.content || '';

          // Extract location and clothing from assistant messages
          let location = '';
          let charClothing = '';
          if (role === 'assistant') {
            // Try to extract JSON block
            const jsonMatch = content.match(/\n\s*\{.*?\}\s*$/s);
            if (jsonMatch) {
              try {
                const memoryData = JSON.parse(jsonMatch[0].trim());
                location = memoryData.location || '';
                const clothingData = memoryData.clothing || {};
                charClothing = typeof clothingData === 'object' ? (clothingData.char || '') : clothingData;
              } catch (e) {}
            }

            // Remove JSON memory block
            content = content.replace(/\n\s*\{.*?\}\s*$/s, '');

            // Remove date lines
            content = content.replace(/^\d{4}-\d{2}-\d{2}(?:\s+\d{4}-\d{2}-\d{2})?\s*/gm, '');
          }

          // Determine speaker - always use "User" for user messages if no name
          let speaker = role === 'user' ? (userName || 'User') : charName;
          const prefix = role === 'user' ? '→' : '←';

          let context = '';
          if (role === 'assistant') {
            if (location && charClothing) {
              context = `\n   📍 ${location}\n   👗 ${charClothing}`;
            } else if (location) {
              context = `\n   📍 ${location}`;
            } else if (charClothing) {
              context = `\n   👗 ${charClothing}`;
            }
          }

          // Clean up content
          content = content.trim();
          content = content.replace(/\n{3,}/g, '\n\n');

          // Clean up user messages
          if (role === 'user') {
            const lines = content.split('\n');
            const cleanedLines = lines.filter(line => !line.match(/^[\*\s]*$/));
            content = cleanedLines.join('\n').trim();
            if (!content) return;
          }

          // Write message
          if (i > 0) output += '\n';
          output += `${prefix} **${speaker}**${context}\n\n`;
          output += `${content}\n`;
          output += '-'.repeat(80) + '\n';
        });

        // Add metadata section
        output += '\n' + '='.repeat(80) + '\n';
        output += '='.repeat(80) + '\n\n';
        output += '## 📋 Session Details\n\n';
        output += `**Character:** ${charName}  \n`;
        output += `**User:** ${userName}  \n`;
        output += `**Date:** ${date}  \n`;
        output += `**Session ID:** ${sessionId}\n\n`;

        // Short-term memory
        const shortTerm = sessionData.memoryState?.shortTerm || [];
        if (shortTerm.length > 0) {
          output += '### 🧠 Short-term Memory\n\n';
          shortTerm.forEach(item => {
            const content = typeof item === 'object' ? (item.content || '') : item;
            if (content) output += `• ${content}\n`;
          });
          output += '\n';
        }

        // History
        const history = sessionData.history || [];
        if (history.length > 0) {
          output += '### 📜 History\n\n';
          history.forEach(item => {
            const change = item.change || '';
            const ts = item.timestamp || '';
            if (change) {
              output += `• ${change}`;
              if (ts) output += ` _${ts}_`;
              output += '\n';
            }
          });
          output += '\n';
        }

        return output;
      }

      // View session JSON
      async function viewSessionJson(sessionId) {
        try {
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl(`/api/session/${sessionId}/json`)
          );

          if (!response.ok) {
            throw new Error(`Failed to load session: ${response.statusText}`);
          }

          const sessionData = await response.json();
          let currentView = 'readable'; // Start with readable view

          // Create and show modal with toggle buttons
          const modal = document.createElement('div');
          modal.className = 'modal fade';
          modal.id = 'jsonViewModal';
          modal.innerHTML = `
            <div class="modal-dialog modal-xl modal-dialog-scrollable">
              <div class="modal-content">
                <div class="modal-header">
                  <h5 class="modal-title">
                    <i class="fas fa-file-alt me-2"></i>Session Data: ${sessionId}
                  </h5>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                  <div class="mb-3 d-flex gap-2">
                    <button class="btn btn-sm btn-primary" id="toggleViewBtn">
                      <i class="fas fa-exchange-alt me-1"></i> <span id="toggleText">Switch to JSON</span>
                    </button>
                    <button class="btn btn-sm btn-outline-primary" id="copyContentBtn">
                      <i class="fas fa-copy me-1"></i> Copy to Clipboard
                    </button>
                  </div>
                  <div id="contentDisplay" style="background-color: #f5f5f5; padding: 1rem; border-radius: 4px; max-height: 70vh; overflow: auto; white-space: pre-wrap; font-family: monospace;"></div>
                </div>
              </div>
            </div>
          `;

          document.body.appendChild(modal);

          const bsModal = new bootstrap.Modal(modal);
          bsModal.show();

          const contentDisplay = document.getElementById('contentDisplay');
          const toggleBtn = document.getElementById('toggleViewBtn');
          const toggleText = document.getElementById('toggleText');
          const copyBtn = document.getElementById('copyContentBtn');

          // Function to update display
          function updateDisplay() {
            if (currentView === 'readable') {
              const readableText = convertToReadable(sessionData);
              contentDisplay.textContent = readableText;
              toggleText.textContent = 'Switch to JSON';
            } else {
              contentDisplay.textContent = JSON.stringify(sessionData, null, 2);
              toggleText.textContent = 'Switch to Readable';
            }
          }

          // Initial display
          updateDisplay();

          // Toggle view
          toggleBtn.addEventListener('click', () => {
            currentView = currentView === 'readable' ? 'json' : 'readable';
            updateDisplay();
          });

          // Copy functionality
          copyBtn.addEventListener('click', () => {
            const textToCopy = contentDisplay.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
              const originalHtml = copyBtn.innerHTML;
              copyBtn.innerHTML = '<i class="fas fa-check me-1"></i> Copied!';
              setTimeout(() => {
                copyBtn.innerHTML = originalHtml;
              }, 2000);
            });
          });

          // Remove modal from DOM when hidden
          modal.addEventListener('hidden.bs.modal', () => {
            modal.remove();
          });
        } catch (error) {
          console.error('Error viewing session JSON:', error);
          alert(`Error loading session data: ${error.message}`);
        }
      }

    });

    // ========================================
    // Character Creator Functionality
    // ========================================
    document.addEventListener('DOMContentLoaded', function() {
      // Character creator state
      let creatorMessages = [];
      let creatorProfile = '';
      let creatorCompleteness = 0;
      let creatorTotalTokens = 0;
      let creatorRoundtrips = 0;

      // DOM Elements
      const creatorInput = document.getElementById('creator-input');
      const creatorSendBtn = document.getElementById('creator-send-btn');
      const creatorNewBtn = document.getElementById('creator-new-btn');
      const creatorSaveBtn = document.getElementById('creator-save-btn');
      const creatorMessagesContainer = document.getElementById('creator-messages');
      const creatorProfilePreview = document.getElementById('creator-profile-preview');
      const creatorFilename = document.getElementById('creator-filename');
      const creatorCompletenessBar = document.getElementById('creator-completeness-bar');
      const creatorCompletenessText = document.getElementById('creator-completeness-text');
      const creatorTokens = document.getElementById('creator-tokens');
      const creatorRoundtripsElem = document.getElementById('creator-roundtrips');
      const creatorValidationErrors = document.getElementById('creator-validation-errors');

      // Event Listeners
      creatorSendBtn.addEventListener('click', sendCreatorMessage);
      creatorInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendCreatorMessage();
        }
      });

      creatorNewBtn.addEventListener('click', resetCreatorSession);
      creatorSaveBtn.addEventListener('click', saveCreatorCharacter);

    // Reset character creator session
    function resetCreatorSession() {
      if (creatorProfile && !confirm('Are you sure? This will discard the current character.')) {
        return;
      }

      creatorMessages = [];
      creatorProfile = '';
      creatorCompleteness = 0;
      creatorTotalTokens = 0;
      creatorRoundtrips = 0;

      creatorMessagesContainer.innerHTML = `
        <div class="text-center text-muted mt-4">
          <i class="fas fa-wand-magic-sparkles fa-3x mb-3" style="opacity: 0.3;"></i>
          <p>Start creating your character by describing them.</p>
          <p class="small">Example: "A shy 28-year-old librarian who loves mystery novels"</p>
        </div>
      `;

      creatorProfilePreview.value = '';
      creatorFilename.value = '';
      creatorValidationErrors.style.display = 'none';

      updateCreatorCompleteness(0);
      updateCreatorMetrics();
    }

    // Send message to character creator
    async function sendCreatorMessage() {
      const message = creatorInput.value.trim();
      if (!message) return;

      // Add user message to UI
      addCreatorMessage(message, true);
      creatorMessages.push({ role: 'user', content: message });
      creatorInput.value = '';

      // Disable send button during API call
      creatorSendBtn.disabled = true;
      creatorSendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';

      try {
        const response = await fetch(window.ServerConfig.buildApiUrl('/api/character/generate'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            description: message,
            conversationHistory: creatorMessages.slice(0, -1), // Don't include last message (just sent)
            currentProfile: creatorProfile || null,
            model: 'claude-3-haiku-20240307'
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to generate character');
        }

        const data = await response.json();

        // Add AI response to UI
        if (data.conversationResponse) {
          addCreatorMessage(data.conversationResponse, false);
          creatorMessages.push({ role: 'assistant', content: data.conversationResponse });
        }

        // Update profile preview
        if (data.characterProfile) {
          creatorProfile = data.characterProfile;
          creatorProfilePreview.value = creatorProfile;

          // Auto-suggest filename from NAME field
          const nameMatch = creatorProfile.match(/NAME:[ \t]+(.*?)(?=[ \t]*[\r\n])/i);
          if (nameMatch && !creatorFilename.value) {
            const suggestedName = nameMatch[1].trim().toLowerCase().replace(/\s+/g, '_');
            creatorFilename.value = `${suggestedName}.txt`;
          }
        }

        // Update completeness
        if (data.completeness !== undefined) {
          updateCreatorCompleteness(data.completeness);
        }

        // Update metrics
        creatorRoundtrips++;
        creatorTotalTokens += (data.usage.input_tokens + data.usage.output_tokens);
        updateCreatorMetrics();

        // Show validation errors if any
        if (data.validation && !data.validation.valid) {
          creatorValidationErrors.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ' +
            data.validation.errors.join('<br>');
          creatorValidationErrors.style.display = 'block';
        } else {
          creatorValidationErrors.style.display = 'none';
        }

      } catch (error) {
        console.error('Error generating character:', error);
        addCreatorMessage(`Error: ${error.message}`, false, true);
      } finally {
        creatorSendBtn.disabled = false;
        creatorSendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send';
      }
    }

    // Add message to creator chat
    function addCreatorMessage(text, isUser, isError = false) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message-bubble mb-3 p-3 rounded ${isUser ? 'ms-auto' : 'me-auto'}`;
      messageDiv.style.maxWidth = '85%';
      messageDiv.style.wordWrap = 'break-word';

      if (isUser) {
        messageDiv.style.backgroundColor = 'var(--light-accent)';
        messageDiv.style.color = 'var(--text-color)';
        messageDiv.innerHTML = `<strong><i class="fas fa-user me-2"></i>You:</strong><br>${escapeHtml(text)}`;
      } else if (isError) {
        messageDiv.style.backgroundColor = '#ffebee';
        messageDiv.style.color = '#c62828';
        messageDiv.innerHTML = `<strong><i class="fas fa-exclamation-circle me-2"></i>Error:</strong><br>${escapeHtml(text)}`;
      } else {
        messageDiv.style.backgroundColor = 'rgba(74, 144, 226, 0.1)';
        messageDiv.style.color = 'var(--text-color)';
        messageDiv.innerHTML = `<strong><i class="fas fa-wand-magic-sparkles me-2"></i>AI:</strong><br>${escapeHtml(text)}`;
      }

      // Remove placeholder if exists
      const placeholder = creatorMessagesContainer.querySelector('.text-center');
      if (placeholder) {
        placeholder.remove();
      }

      creatorMessagesContainer.appendChild(messageDiv);
      creatorMessagesContainer.scrollTop = creatorMessagesContainer.scrollHeight;
    }

    // Update completeness bar
    function updateCreatorCompleteness(completeness) {
      creatorCompleteness = completeness;
      creatorCompletenessBar.style.width = `${completeness}%`;
      creatorCompletenessBar.setAttribute('aria-valuenow', completeness);
      creatorCompletenessText.textContent = `${completeness}%`;

      // Color coding based on completeness
      let color;
      if (completeness < 30) {
        color = '#ff4d4d'; // Red
      } else if (completeness < 70) {
        color = '#ffcc00'; // Yellow
      } else {
        color = '#4caf50'; // Green
      }
      creatorCompletenessBar.style.backgroundColor = color;
    }

    // Update metrics display
    function updateCreatorMetrics() {
      creatorTokens.textContent = creatorTotalTokens.toLocaleString();
      creatorRoundtripsElem.textContent = creatorRoundtrips;
    }

    // Save character to /characters folder
    async function saveCreatorCharacter() {
      // Get profile from textarea (allows manual edits)
      const profileContent = creatorProfilePreview.value.trim();
      const filename = creatorFilename.value.trim();

      if (!profileContent) {
        alert('No character profile to save. Please create a character first.');
        return;
      }

      if (!filename) {
        alert('Please enter a filename.');
        return;
      }

      creatorSaveBtn.disabled = true;
      creatorSaveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

      try {
        const response = await fetch(window.ServerConfig.buildApiUrl('/api/character/save'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            filename: filename,
            content: profileContent
          })
        });

        const data = await response.json();

        if (!response.ok) {
          if (response.status === 409) {
            if (confirm(`Character "${data.filename}" already exists. Do you want to choose a different name?`)) {
              creatorFilename.focus();
              creatorFilename.select();
            }
            throw new Error(data.error);
          } else if (data.validationErrors) {
            creatorValidationErrors.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ' +
              data.validationErrors.join('<br>');
            creatorValidationErrors.style.display = 'block';
            throw new Error('Profile validation failed');
          } else {
            throw new Error(data.error || 'Failed to save character');
          }
        }

        // Success!
        creatorValidationErrors.style.display = 'none';
        addCreatorMessage(`Character saved successfully as "${data.filename}"! You can now use it in sessions.`, false);

        // Reload character list in main UI
        if (typeof loadAvailableCharacters === 'function') {
          loadAvailableCharacters();
        }

        // Optional: Reset session after save
        setTimeout(() => {
          if (confirm('Character saved! Do you want to create another character?')) {
            resetCreatorSession();
          }
        }, 500);

      } catch (error) {
        console.error('Error saving character:', error);
        if (!error.message.includes('validation')) {
          alert(`Error saving character: ${error.message}`);
        }
      } finally {
        creatorSaveBtn.disabled = false;
        creatorSaveBtn.innerHTML = '<i class="fas fa-save"></i> Save to Characters';
      }
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

      // Initialize creator when modal is shown
      document.getElementById('characterCreatorModal').addEventListener('shown.bs.modal', function() {
        creatorInput.focus();
      });

      async function loadSessions() {
        const loadingEl = document.getElementById('sessions-loading');
        const emptyEl = document.getElementById('sessions-empty');
        const listEl = document.getElementById('sessions-list');

        // Show loading state
        loadingEl.style.display = 'block';
        emptyEl.style.display = 'none';
        listEl.innerHTML = '';

        try {
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl('/api/sessions')
          );

          if (!response.ok) {
            throw new Error(`Failed to load sessions: ${response.statusText}`);
          }

          allSessions = await response.json();
          filteredSessions = [...allSessions];

          loadingEl.style.display = 'none';

          if (allSessions.length === 0) {
            emptyEl.style.display = 'block';
          } else {
            renderSessions(filteredSessions);
          }
        } catch (error) {
          console.error('Error loading sessions:', error);
          loadingEl.style.display = 'none';
          emptyEl.style.display = 'block';
          listEl.innerHTML = `<div class="col-12"><div class="alert alert-danger">Error loading sessions: ${error.message}</div></div>`;
        }
      }

      function filterSessions(searchTerm) {
        if (!searchTerm) {
          filteredSessions = [...allSessions];
        } else {
          filteredSessions = allSessions.filter(session => {
            const characterMatch = session.characterName && session.characterName.toLowerCase().includes(searchTerm);
            const userMatch = session.userName && session.userName.toLowerCase().includes(searchTerm);
            return characterMatch || userMatch;
          });
        }

        const emptyEl = document.getElementById('sessions-empty');
        const listEl = document.getElementById('sessions-list');

        if (filteredSessions.length === 0) {
          emptyEl.style.display = 'block';
          listEl.innerHTML = '';
        } else {
          emptyEl.style.display = 'none';
          renderSessions(filteredSessions);
        }
      }

      function renderSessions(sessions) {
        const listEl = document.getElementById('sessions-list');
        listEl.innerHTML = '';

        sessions.forEach(session => {
          const card = createSessionCard(session);
          listEl.appendChild(card);
        });
      }

      function createSessionCard(session) {
        const col = document.createElement('div');
        col.className = 'col-12';

        const firstDate = new Date(session.firstMessageDate).toLocaleDateString();
        const lastDate = new Date(session.lastMessageDate).toLocaleDateString();
        const userName = session.userName || '<span class="text-muted">Unknown</span>';

        col.innerHTML = `
          <div class="card" style="transition: transform 0.2s;">
            <div class="card-body">
              <div class="row">
                <div class="col-md-8">
                  <h6 class="card-title mb-2">
                    <i class="fas fa-user-circle me-1" style="color: var(--primary-color);"></i>
                    <strong>Character:</strong> ${escapeHtml(session.characterName)}
                  </h6>
                  <p class="card-text small mb-1">
                    <i class="fas fa-user me-1" style="color: var(--dark-accent);"></i>
                    <strong>User:</strong> ${userName}
                  </p>
                  <p class="card-text small mb-1">
                    <i class="fas fa-comments me-1" style="color: var(--dark-accent);"></i>
                    <strong>Messages:</strong> ${session.messageCount}
                  </p>
                  <p class="card-text small text-muted mb-0">
                    <i class="fas fa-calendar me-1"></i>
                    <strong>First:</strong> ${firstDate} | <strong>Last:</strong> ${lastDate}
                  </p>
                </div>
                <div class="col-md-4 d-flex flex-column justify-content-center align-items-end">
                  <button class="btn btn-sm btn-primary mb-2 w-100 resume-btn" data-session-id="${session.sessionId}">
                    <i class="fas fa-play me-1"></i> Resume
                  </button>
                  <button class="btn btn-sm btn-outline-danger w-100 delete-btn" data-session-id="${session.sessionId}" data-character-name="${escapeHtml(session.characterName)}">
                    <i class="fas fa-trash me-1"></i> Delete
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;

        // Add event listeners
        const resumeBtn = col.querySelector('.resume-btn');
        const deleteBtn = col.querySelector('.delete-btn');

        resumeBtn.addEventListener('click', () => {
          window.resumeSession(session.sessionId);
        });

        deleteBtn.addEventListener('click', () => {
          window.deleteSessionConfirm(session.sessionId, session.characterName);
        });

        return col;
      }

      // Global functions for button handlers
      window.resumeSession = async function(sessionId) {
        try {
          // Load the session (using same approach as existing Load Session)
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl('/api/session'),
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                sessionId: sessionId,
                apiKey: null, // Will use stored API key
                language: 'english' // Default language
              })
            }
          );

          const data = await response.json();

          if (!response.ok) {
            alert(`Error: ${data.error || 'Failed to load session'}`);
            return;
          }

          // Update UI - matching the existing Load Session behavior
          // CRITICAL: Set activeSessionId directly (not checking if defined, just set it)
          activeSessionId = data.sessionId;
          console.log('Resume: Set activeSessionId to:', activeSessionId);
          console.log('Resume: Session data:', data);

          // Debug: Check if it persists after a delay
          setTimeout(() => {
            console.log('Resume: activeSessionId after 100ms:', activeSessionId);
          }, 100);
          setTimeout(() => {
            console.log('Resume: activeSessionId after 1000ms:', activeSessionId);
          }, 1000);

          const characterNameElement = document.getElementById('character-name');
          const sessionInfoElement = document.getElementById('session-info');
          const saveStatusElement = document.getElementById('save-status');
          const saveSessionButton = document.getElementById('save-session-btn');
          const setupContainer = document.getElementById('setup-container');
          const sessionLoader = document.getElementById('session-loader');
          const chatContainer = document.getElementById('chat-container');
          const sessionInfoCard = document.getElementById('session-info-card');
          const welcomePlaceholder = document.getElementById('welcome-placeholder');
          const messagesContainer = document.getElementById('messages');
          const memoryPanel = document.getElementById('memory-panel');
          const compressionToggle = document.getElementById('compression-toggle');

          if (characterNameElement) characterNameElement.textContent = data.characterName;
          if (sessionInfoElement) sessionInfoElement.textContent = `Active session: ${data.characterName}`;
          if (saveStatusElement) saveStatusElement.textContent = 'Auto-saving enabled';
          if (saveSessionButton) saveSessionButton.disabled = false;

          // Set character avatar background color
          if (typeof setCharacterAvatar === 'function') {
            setCharacterAvatar(data.characterType);
          }

          // Hide setup and show chat
          if (setupContainer) setupContainer.style.display = 'none';
          if (sessionLoader) sessionLoader.style.display = 'none';
          if (chatContainer) chatContainer.style.display = 'flex';
          if (sessionInfoCard) sessionInfoCard.style.display = 'flex';

          // Hide welcome placeholder
          if (welcomePlaceholder) welcomePlaceholder.style.display = 'none';

          // Clear messages and add system message
          if (messagesContainer) {
            messagesContainer.innerHTML = '';
            if (typeof addSystemMessage === 'function') {
              addSystemMessage(`Session loaded! Continue your conversation with ${data.characterName}.`);
            }
          }

          // Update model badge and currentModel variable if available
          const modelBadge = document.getElementById('model-badge');
          if (data.model) {
            // CRITICAL: Set currentModel directly
            currentModel = data.model;
            if (modelBadge && typeof updateModelBadge === 'function') {
              updateModelBadge(data.model);
            }
          }

          // Update memory display if visible
          if (memoryPanel && memoryPanel.style.display !== 'none' && typeof updateMemoryDisplay === 'function') {
            updateMemoryDisplay(data.memoryState);
          }

          // Update header badges with current location and clothing
          if (data.memoryState && typeof updateHeaderBadges === 'function') {
            updateHeaderBadges(data.memoryState.location, data.memoryState.clothing);
          }

          // Update compression toggle
          if (compressionToggle && data.memoryState && data.memoryState.compressionEnabled !== undefined) {
            compressionToggle.checked = data.memoryState.compressionEnabled;
          }

          // Update compression stats
          if (typeof updateCompressionStats === 'function') {
            updateCompressionStats();
          }

          // Close the modal AFTER everything is set up
          const modal = bootstrap.Modal.getInstance(document.getElementById('sessionManagerModal'));
          if (modal) modal.hide();
        } catch (error) {
          console.error('Error resuming session:', error);
          alert(`Error resuming session: ${error.message}`);
        }
      };

      window.deleteSessionConfirm = function(sessionId, characterName) {
        if (confirm(`Are you sure you want to delete the chat with ${characterName}?\n\nThis action cannot be undone.`)) {
          deleteSession(sessionId);
        }
      };

      async function deleteSession(sessionId) {
        try {
          const response = await window.ServerConfig.fetchWithCredentials(
            window.ServerConfig.buildApiUrl(`/api/session/${sessionId}`),
            {
              method: 'DELETE'
            }
          );

          if (!response.ok) {
            throw new Error(`Failed to delete session: ${response.statusText}`);
          }

          // Reload sessions list
          await loadSessions();

          // If this was the active session, reset the UI
          if (typeof activeSessionId !== 'undefined' && activeSessionId === sessionId) {
            activeSessionId = null;
            const setupContainer = document.getElementById('setup-container');
            const chatContainer = document.getElementById('chat-container');
            const sessionInfoCard = document.getElementById('session-info-card');
            const chatMessagesEl = document.getElementById('chat-messages');

            if (setupContainer) setupContainer.style.display = 'block';
            if (chatContainer) chatContainer.style.display = 'none';
            if (sessionInfoCard) sessionInfoCard.style.display = 'none';
            if (chatMessagesEl) chatMessagesEl.innerHTML = '';
          }
        } catch (error) {
          console.error('Error deleting session:', error);
          alert(`Error deleting session: ${error.message}`);
        }
      }

    }); // End DOMContentLoaded
  </script>

  <!-- Character Creator Modal -->
  <div class="modal fade" id="characterCreatorModal" tabindex="-1" aria-labelledby="characterCreatorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered">
      <div class="modal-content" style="background-color: var(--card-bg-color); color: var(--text-color); max-height: 90vh; display: flex; flex-direction: column;">
        <div class="modal-header" style="border-bottom: 1px solid rgba(74, 144, 226, 0.1); flex-shrink: 0;">
          <h5 class="modal-title" id="characterCreatorModalLabel">
            <i class="fas fa-wand-magic-sparkles me-2"></i>Character Creator
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" style="padding: 0; overflow: hidden; flex: 1; min-height: 0;">
          <div class="row g-0 h-100">
            <!-- Left Panel: Chat Interface -->
            <div class="col-md-6 h-100" style="border-right: 1px solid rgba(74, 144, 226, 0.1); display: flex; flex-direction: column;">
              <div class="p-2" style="border-bottom: 1px solid rgba(74, 144, 226, 0.1); flex: 0 0 auto;">
                <!-- Completeness Progress Bar -->
                <div class="mb-1">
                  <small class="text-muted">Completeness: <span id="creator-completeness-text">0%</span></small>
                </div>
                <div class="progress" style="height: 10px; background-color: rgba(74, 144, 226, 0.1);">
                  <div id="creator-completeness-bar" class="progress-bar"
                       role="progressbar"
                       style="width: 0%; background-color: #ff4d4d; transition: width 0.5s ease-in-out, background-color 0.3s;"
                       aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
              </div>

              <!-- Chat Messages -->
              <div id="creator-messages" class="p-3" style="background-color: rgba(0,0,0,0.02); flex: 1 1 0; min-height: 500px; overflow-y: auto; overflow-x: hidden;">
                <div class="text-center text-muted mt-4">
                  <i class="fas fa-wand-magic-sparkles fa-3x mb-3" style="opacity: 0.3;"></i>
                  <p>Start creating your character by describing them.</p>
                  <p class="small">Example: "A shy 28-year-old librarian who loves mystery novels"</p>
                </div>
              </div>

              <!-- Input Area -->
              <div class="p-2" style="border-top: 1px solid rgba(74, 144, 226, 0.1); flex: 0 0 auto;">
                <div class="input-group input-group-sm mb-1">
                  <input type="text" id="creator-input" class="form-control form-control-sm"
                         placeholder="Describe your character or ask for refinements..."
                         style="background-color: white; border: 1px solid rgba(74, 144, 226, 0.2);">
                  <button id="creator-send-btn" class="btn btn-primary btn-sm">
                    <i class="fas fa-paper-plane"></i> Send
                  </button>
                </div>
                <div class="d-flex justify-content-between align-items-center">
                  <small class="text-muted" style="font-size: 0.7rem;">
                    Tokens: <span id="creator-tokens">0</span> | Calls: <span id="creator-roundtrips">0</span>
                  </small>
                  <button id="creator-new-btn" class="btn btn-sm btn-outline-secondary" style="padding: 0.15rem 0.4rem; font-size: 0.75rem;">
                    <i class="fas fa-plus"></i> New
                  </button>
                </div>
              </div>
            </div>

            <!-- Right Panel: Profile Preview & Edit -->
            <div class="col-md-6 h-100" style="display: flex; flex-direction: column;">
              <div class="p-2" style="border-bottom: 1px solid rgba(74, 144, 226, 0.1); flex: 0 0 auto;">
                <h6 class="mb-0">Character Profile</h6>
              </div>

              <!-- Profile Editor -->
              <div class="p-3 overflow-auto" style="flex: 1 1 0; min-height: 500px;">
                <textarea id="creator-profile-preview" class="form-control font-monospace"
                          placeholder="Profile will appear here... You can edit it directly."
                          rows="20"
                          style="background-color: rgba(0,0,0,0.02); border: 1px solid rgba(74, 144, 226, 0.1); color: var(--text-color); font-size: 0.85rem; min-height: 400px;"></textarea>
              </div>

              <!-- Save Controls -->
              <div class="p-2" style="border-top: 1px solid rgba(74, 144, 226, 0.1); flex: 0 0 auto;">
                <div class="input-group input-group-sm">
                  <span class="input-group-text" style="background-color: rgba(74, 144, 226, 0.1); border: 1px solid rgba(74, 144, 226, 0.2);">
                    <i class="fas fa-file"></i>
                  </span>
                  <input type="text" id="creator-filename" class="form-control form-control-sm"
                         placeholder="filename.txt"
                         style="background-color: white; border: 1px solid rgba(74, 144, 226, 0.2);">
                  <button id="creator-save-btn" class="btn btn-success btn-sm">
                    <i class="fas fa-save"></i> Save
                  </button>
                </div>
                <div id="creator-validation-errors" class="text-danger" style="display: none; font-size: 0.7rem; margin-top: 0.25rem;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Server Configuration Modal -->
  <div class="modal fade" id="serverConfigModal" tabindex="-1" aria-labelledby="serverConfigModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="serverConfigModalLabel">
            <i class="fas fa-server me-2"></i>Server Configuration
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="serverUrl" class="form-label">Server URL</label>
            <input type="url" class="form-control" id="serverUrl" 
                   placeholder="https://your-server.com" 
                   value="">
            <div class="form-text">
              Enter the full URL of your Persona server (e.g., https://your-server.com or http://192.168.1.100:3000)
            </div>
          </div>
          <div class="mb-3">
            <div class="alert alert-info" role="alert">
              <i class="fas fa-info-circle me-2"></i>
              <strong>Current server:</strong> <span id="currentServerUrl"></span>
            </div>
          </div>
          <div class="mb-3">
            <button type="button" class="btn btn-outline-primary" id="testConnectionBtn">
              <i class="fas fa-wifi me-1"></i> Test Connection
            </button>
            <span id="connectionStatus" class="ms-2"></span>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="saveServerConfig">Save Configuration</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Session Manager Modal -->
  <div class="modal fade" id="sessionManagerModal" tabindex="-1" aria-labelledby="sessionManagerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header" style="border-bottom: 1px solid rgba(74, 144, 226, 0.1);">
          <h5 class="modal-title" id="sessionManagerModalLabel">
            <i class="fas fa-history me-2"></i><span data-i18n="previous_chats_title">Previous Chats</span>
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" style="padding: 1.5rem;">
          <!-- Search/Filter -->
          <div class="mb-3">
            <div class="input-group">
              <span class="input-group-text"><i class="fas fa-search"></i></span>
              <input type="text" id="session-search" class="form-control" placeholder="Search by character or user name..." />
            </div>
          </div>

          <!-- Loading State -->
          <div id="sessions-loading" class="text-center py-5" style="display: none;">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="text-muted mt-2">Loading sessions...</p>
          </div>

          <!-- Empty State -->
          <div id="sessions-empty" class="text-center py-5" style="display: none;">
            <i class="fas fa-inbox fa-3x text-muted mb-3" style="opacity: 0.3;"></i>
            <p class="text-muted">No previous chats found</p>
          </div>

          <!-- Sessions List -->
          <div id="sessions-list" class="row g-3">
            <!-- Session cards will be dynamically inserted here -->
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>